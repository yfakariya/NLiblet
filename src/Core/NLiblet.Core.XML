<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NLiblet.CoreUtilities</name>
  </assembly>
  <members>
    <member name="T:NLiblet.Collections.ArraySegmentExtensions">
      <summary>
            	Extension methods to use <see cref="T:System.ArraySegment`1" /> more easily.
            </summary>
    </member>
    <member name="M:NLiblet.Collections.ArraySegmentExtensions.AsEnumerable``1(System.ArraySegment{``0})">
      <summary>
            	Get <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerent items in the segment.
            </summary>
      <typeparam name="T">Type of item.</typeparam>
      <param name="source">
        <see cref="T:System.ArraySegment`1" />
      </param>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerent items in the segment.
            	If the segment of <paramref name="source" /> is empty or is not available then empty.
            </returns>
      <pure />
      <ensures> Contract.Result&lt;IEnumerable&lt;T&gt;&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Collections.ArraySegmentExtensions.GetItemAt``1(System.ArraySegment{``0},System.Int32)">
      <summary>
            	Get item of <see cref="T:System.ArraySegment`1" /> at specified <paramref name="relativeIndex" />.
            </summary>
      <typeparam name="T">Type of item of <see cref="T:System.ArraySegment`1" />.</typeparam>
      <param name="source">
        <see cref="T:System.ArraySegment`1" />.</param>
      <param name="relativeIndex">
            	Relative index of the item from <see cref="P:System.ArraySegment`1.Offset" />.
            </param>
      <returns>
            	Item at <paramref name="relativeIndex" />,
            	thus item at <see cref="P:System.ArraySegment`1.Offset" /> + <paramref name="relativeIndex" />.
            </returns>
      <requires exception="T:System.ArgumentException"> source.Array != null </requires>
      <exception cref="T:System.ArgumentException"> source.Array == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= relativeIndex </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; relativeIndex </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> relativeIndex &lt; source.Count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> relativeIndex &gt;= source.Count </exception>
    </member>
    <member name="M:NLiblet.Collections.ArraySegmentExtensions.SetItemAt``1(System.ArraySegment{``0},System.Int32,``0)">
      <summary>
            	Set item of <see cref="T:System.ArraySegment`1" /> at specified <paramref name="relativeIndex" />.
            </summary>
      <typeparam name="T">Type of item of <see cref="T:System.ArraySegment`1" />.</typeparam>
      <param name="source">
        <see cref="T:System.ArraySegment`1" />.</param>
      <param name="relativeIndex">
            	Relative index of the item from <see cref="P:System.ArraySegment`1.Offset" />.
            </param>
      <param name="value">
            	Value to be set at <paramref name="relativeIndex" />,
            	thus item at <see cref="P:System.ArraySegment`1.Offset" /> + <paramref name="relativeIndex" />.
            </param>
      <requires exception="T:System.ArgumentException"> source.Array != null </requires>
      <exception cref="T:System.ArgumentException"> source.Array == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= relativeIndex </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; relativeIndex </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> relativeIndex &lt; source.Count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> relativeIndex &gt;= source.Count </exception>
    </member>
    <member name="T:NLiblet.Collections.CollectionDebuggerProxy`1">
      <summary>
            	Debugger type proxy for <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <typeparam name="T">The element type of the collection.</typeparam>
    </member>
    <member name="T:NLiblet.Collections.DelegateEqualityComparer`1">
      <summary>
            Implements <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> with delegate.
            </summary>
      <typeparam name="T">Type of target.</typeparam>
    </member>
    <member name="M:NLiblet.Collections.DelegateEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
      <summary>
            Initializes a new instance of the <see cref="T:NLiblet.Collections.DelegateEqualityComparer`1" /> class.
            </summary>
      <param name="equalityComparison">The equality comparison.</param>
      <param name="hashCodeProvider">The hash code provider.</param>
      <requires exception="T:System.ArgumentNullException"> equalityComparison != null </requires>
      <exception cref="T:System.ArgumentNullException"> equalityComparison == null </exception>
      <requires exception="T:System.ArgumentNullException"> hashCodeProvider != null </requires>
      <exception cref="T:System.ArgumentNullException"> hashCodeProvider == null </exception>
    </member>
    <member name="M:NLiblet.Collections.DelegateEqualityComparer`1.Equals(`0,`0)">
      <summary>
            	Determines whether the specified objects are equal.
            </summary>
      <param name="x">The first object of type <typeparamref name="T" /> to compare.</param>
      <param name="y">The second object of type <typeparamref name="T" /> to compare.</param>
      <returns>
            	true if the specified objects are equal; otherwise, false.
            </returns>
      <pure />
    </member>
    <member name="M:NLiblet.Collections.DelegateEqualityComparer`1.GetHashCode(`0)">
      <summary>
            	Returns a hash code <typeparamref name="T" /> instance..
            </summary>
      <param name="obj">Target.</param>
      <returns>
            	A hash code for <paramref name="obj" /> instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
      <pure />
    </member>
    <member name="T:NLiblet.Collections.DictionaryDebuggerProxy`2">
      <summary>
            	Debugger type proxy for <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="T:NLiblet.Collections.ReadOnlyDictionary`2">
      <summary>
            	Provides the base class for a read-only collection of key/value pairs.
            </summary>
      <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of values in the dictionary.</typeparam>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" /> class.
            </summary>
      <param name="dictionary">The dictionary.</param>
      <requires exception="T:System.ArgumentNullException"> dictionary != null </requires>
      <exception cref="T:System.ArgumentNullException"> dictionary == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.ContainsKey(`0)">
      <summary>
            	Determines whether the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" /> contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.</param>
      <returns>
        <c>true</c> if the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" /> contains an element with the key; otherwise, <c>false</c>.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary">!Contract.Result&lt;bool&gt;() || @this.Count &gt; 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
      <summary>
            	Gets the value associated with the specified key.
            </summary>
      <param name="key">The key whose value to get.</param>
      <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed uninitialized.</param>
      <returns>
        <c>true</c> if the object that implements <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" /> contains an element with the specified key; otherwise, <c>false</c>.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary">Contract.Result&lt;bool&gt;() == @this.ContainsKey(key)</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.Count">
      <summary>
            	Gets the number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.
            </summary>
      <returns>
            	The number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.
            </returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.Item(`0)">
      <summary>
            	Gets or sets the element with the specified key.
            </summary>
      <returns>
            	The element with the specified key.
            </returns>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.Keys">
      <summary>
            	Gets an <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" /> containing the keys of the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.
            </summary>
      <returns>
            	An <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" /> containing the keys of the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.
              </returns>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.Values">
      <summary>
            	Gets an <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" /> containing the values of the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.
            </summary>
      <returns>
            	An <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" /> containing the values of the <see cref="T:NLiblet.Collections.ReadOnlyDictionary`2" />.
              </returns>
    </member>
    <member name="T:NLiblet.Collections.ReadOnlyKeyedCollection`2">
      <summary>
            	Provides the base class for a read-only collection whose keys are embedded in the values.
            </summary>
      <typeparam name="TKey">The type of keys in the collection.</typeparam>
      <typeparam name="TItem">The type of items in the collection.</typeparam>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.#ctor(System.Collections.ObjectModel.KeyedCollection{`0,`1})">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" /> class which wraps specified <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.
            </summary>
      <param name="underlying">
        <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> to be wrapped.</param>
      <requires exception="T:System.ArgumentNullException"> underlying != null </requires>
      <exception cref="T:System.ArgumentNullException"> underlying == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Func{`1,`0})">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" /> class which wraps specified <see cref="T:System.Collections.Generic.IEnumerable`1" /> 
            	and uses the default equality comparer.
            </summary>
      <param name="collection">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be wrapped.</param>
      <param name="keyExtracter">Delegate to procedure which extract <typeparamref name="TKey" /> type keys from <typeparamref name="TItem" /> type items of <paramref name="collection" />.</param>
      <requires exception="T:System.ArgumentNullException"> collection != null </requires>
      <exception cref="T:System.ArgumentNullException"> collection == null </exception>
      <requires exception="T:System.ArgumentNullException"> keyExtracter != null </requires>
      <exception cref="T:System.ArgumentNullException"> keyExtracter == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Func{`1,`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" /> class which wraps specified <see cref="T:System.Collections.Generic.IEnumerable`1" /> 
            	and uses the specified equality comparer.
            </summary>
      <param name="collection">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be wrapped.</param>
      <param name="keyExtracter">Delegate to procedure which extract <typeparamref name="TKey" /> type keys from <typeparamref name="TItem" /> type items of <paramref name="collection" />.</param>
      <param name="comparer">The implementation of the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> generic interface to use when comparing keys, or <c>null</c> to use the default equality comparer for the type of the key, obtained from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
      <requires exception="T:System.ArgumentNullException"> collection != null </requires>
      <exception cref="T:System.ArgumentNullException"> collection == null </exception>
      <requires exception="T:System.ArgumentNullException"> keyExtracter != null </requires>
      <exception cref="T:System.ArgumentNullException"> keyExtracter == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Func{`1,`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" /> class which wraps specified <see cref="T:System.Collections.Generic.IEnumerable`1" /> 
            	and uses specified equality comparer and and creates a lookup dictionary when the specified threshold is exceeded.
            </summary>
      <param name="collection">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> to be wrapped.</param>
      <param name="keyExtracter">Delegate to procedure which extract <typeparamref name="TKey" /> type keys from <typeparamref name="TItem" /> type items of <paramref name="collection" />.</param>
      <param name="comparer">The implementation of the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> generic interface to use when comparing keys, or <c>null</c> to use the default equality comparer for the type of the key, obtained from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
      <param name="dictionaryCreationThreshold">The number of elements the collection can hold without creating a lookup dictionary (0 creates the lookup dictionary when the first item is added), or –1 to specify that a lookup dictionary is never created.</param>
      <requires exception="T:System.ArgumentNullException"> collection != null </requires>
      <exception cref="T:System.ArgumentNullException"> collection == null </exception>
      <requires exception="T:System.ArgumentNullException"> keyExtracter != null </requires>
      <exception cref="T:System.ArgumentNullException"> keyExtracter == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.Contains(`1)">
      <summary>
            	Determines whether the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" />.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" />; otherwise, <c>false</c>.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.CopyTo(`1[],System.Int32)">
      <summary>
            	Copies the elements of the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">
            	The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:NLiblet.Collections.ReadOnlySet`1" />. 
            	The <see cref="T:System.Array" /> must have zero-based indexing.
            </param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.GetEnumerator">
      <summary>
            	Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            	A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyKeyedCollection`2.Count">
      <summary>
            	Gets the number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" />.
            </summary>
      <returns>
            	The number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlyKeyedCollection`2" />.
            </returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:NLiblet.Collections.ReadOnlyNonListCollection`1">
      <summary>
            	Provides the base class for a generic read-only collection but it does not have index.
            </summary>
      <typeparam name="T">The type of elements in the collection.</typeparam>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" /> class.
            </summary>
      <param name="collection">Collection to be wrapped.</param>
      <requires exception="T:System.ArgumentNullException"> collection != null </requires>
      <exception cref="T:System.ArgumentNullException"> collection == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.Contains(`0)">
      <summary>
            	Determines whether the <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" />.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" />; otherwise, <c>false</c>.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.CopyTo(`0[],System.Int32)">
      <summary>
            	Copies items of this instance to specified array.
            </summary>
      <param name="array">The array.</param>
      <param name="arrayIndex">Start index of the array to be copied.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyNonListCollection`1.Items">
      <summary>
            	Gets modifiable underlying collection of this instance.
            </summary>
      <value>
            	Modifiable underlying collection of this instance.
            </value>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyNonListCollection`1.Count">
      <summary>
            	Gets the number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" />.
            </summary>
      <returns>
            	The number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlyNonListCollection`1" />.
              </returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:NLiblet.Collections.ReadOnlySet`1">
      <summary>
            	Provides the base class for a generic read-only set.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.#ctor(System.Collections.Generic.ISet{`0})">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Collections.ReadOnlySet`1" /> class.
            </summary>
      <param name="items">The <see cref="T:System.Collections.Generic.ISet`1" /> that the <see cref="T:NLiblet.Collections.ReadOnlySet`1" /> wraps.</param>
      <requires exception="T:System.ArgumentNullException"> items != null </requires>
      <exception cref="T:System.ArgumentNullException"> items == null </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            	Determines whether the current set is a property (strict) subset of a specified collection.
            </summary>
      <param name="other">The collection to compare to the current set.</param>
      <returns>
        <c>true</c>if the current set is a correct subset of <paramref name="other" />; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            	Determines whether the current set is a correct superset of a specified collection.
            </summary>
      <param name="other">The collection to compare to the current set. </param>
      <returns>
        <c>true</c> if the current set is a correct superset of <paramref name="other" />; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            	Determines whether a set is a subset of a specified collection.
            </summary>
      <param name="other">The collection to compare to the current set.</param>
      <returns>
        <c>true</c> if the current set is a subset of <paramref name="other" />; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            	Determines whether a set is a superset of a specified collection.
            </summary>
      <param name="other">The collection to compare to the current set.</param>
      <returns>
        <c>true</c> if the current set is a superset of <paramref name="other" />; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            	Determines whether the current set overlaps with the specified collection.
            </summary>
      <param name="other">The collection to compare to the current set.</param>
      <returns>
        <c>true</c> if the current set and <paramref name="other" /> share at least one common element; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            	Determines whether the current set and the specified collection contain the same elements.
            </summary>
      <param name="other">The collection to compare to the current set.</param>
      <returns>
        <c>true</c> if the current set is equal to <paramref name="other" />; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.Contains(`0)">
      <summary>
            	Determines whether the <see cref="T:NLiblet.Collections.ReadOnlySet`1" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:NLiblet.Collections.ReadOnlySet`1" />.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <see cref="T:NLiblet.Collections.ReadOnlySet`1" />; otherwise, <c>false</c>.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection">!Contract.Result&lt;bool&gt;() || this.Count &gt; 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.CopyTo(`0[],System.Int32)">
      <summary>
            	Copies the elements of the <see cref="T:NLiblet.Collections.ReadOnlySet`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">
            	The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:NLiblet.Collections.ReadOnlySet`1" />. 
            	The <see cref="T:System.Array" /> must have zero-based indexing.
            </param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.GetEnumerator">
      <summary>
            	Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            	A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlySet`1.Items">
      <summary>
            		Returns the <see cref="T:System.Collections.Generic.ISet`1" /> that the <see cref="T:NLiblet.Collections.ReadOnlySet`1" /> wraps.
            </summary>
      <value>The <see cref="T:System.Collections.Generic.ISet`1" /> that the <see cref="T:NLiblet.Collections.ReadOnlySet`1" /> wraps.</value>
      <getter>
        <ensures> Contract.Result&lt;ISet&lt;T&gt;&gt;() != null </ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlySet`1.Count">
      <summary>
            	Gets the number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlySet`1" />.
            </summary>
      <returns>
            	The number of elements contained in the <see cref="T:NLiblet.Collections.ReadOnlySet`1" />.
            </returns>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_Count" inheritedFromTypeName="ICollection">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="T:NLiblet.Empty">
      <summary>
            	Utlities for empty collections.
            </summary>
    </member>
    <member name="M:NLiblet.Empty.Array``1">
      <summary>
            	Get singleton empty array for specified type.
            </summary>
      <typeparam name="T">Type of array.</typeparam>
      <returns>Singleton instance of empty array.</returns>
      <remarks>
            	Empty array is immutable.
            </remarks>
      <ensures> Contract.Result&lt;T[]&gt;() != null </ensures>
      <ensures> Contract.Result&lt;T[]&gt;().Length == 0 </ensures>
    </member>
    <member name="M:NLiblet.Empty.ReadOnlyCollection``1">
      <summary>
            	Get singleton empty <see cref="M:NLiblet.Empty.ReadOnlyCollection``1" /> for specified type.
            </summary>
      <typeparam name="T">Item type of <see cref="M:NLiblet.Empty.ReadOnlyCollection``1" />.</typeparam>
      <returns>Singleton instance of empty <see cref="M:NLiblet.Empty.ReadOnlyCollection``1" />.</returns>
      <ensures> Contract.Result&lt;ReadOnlyCollection&lt;T&gt;&gt;() != null </ensures>
      <ensures> Contract.Result&lt;ReadOnlyCollection&lt;T&gt;&gt;().Count == 0 </ensures>
    </member>
    <member name="T:NLiblet.HashCodeBuilder">
      <summary>
            	Provide hash code building feature.
            </summary>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.Append``1(``0)">
      <summary>
            	Append hash code for specified value and returns new <see cref="T:NLiblet.HashCodeBuilder" /> to chain.
            </summary>
      <typeparam name="T">Type of value.</typeparam>
      <param name="value">Value to append its hash code. This value can be <c>null</c>.</param>
      <returns>New <see cref="T:NLiblet.HashCodeBuilder" /> to chain.</returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.BuildHashCode">
      <summary>
            	Get hash code built.
            </summary>
      <returns>Hash code built.</returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.GetHashCode">
      <summary>
            	Get hash code built.
            </summary>
      <returns>Hash code built.</returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.Equals(System.Object)">
      <summary>
            	Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.Equals(NLiblet.HashCodeBuilder)">
      <summary>
            	Determines whether the specified same type other <see cref="T:NLiblet.HashCodeBuilder" /> is equal to this instance.
            </summary>
      <param name="other">The <see cref="T:NLiblet.HashCodeBuilder" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if <paramref name="other" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.op_Equality(NLiblet.HashCodeBuilder,NLiblet.HashCodeBuilder)">
      <summary>
            	Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>
            	The result of the operator.
            </returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.op_Inequality(NLiblet.HashCodeBuilder,NLiblet.HashCodeBuilder)">
      <summary>
            	Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>
            	The result of the operator.
            </returns>
    </member>
    <member name="T:NLiblet.IO.ByteArraySegmentsStream">
      <summary>
            	Wraps <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:System.ArraySegment`1" /> of <see cref="T:System.Byte" /> as <see cref="T:System.IO.Stream" />.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._defaultAllocationSize">
      <summary>
            	Default allocation size for a segment.
            	To avoid LOH allocation, this size is 64KiB now.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._isDisposed">
      <summary>
            	Flag that indicates this instance is disposed. 
            	This field shall be updated via atomic operation.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._buffer">
      <summary>
            	Chunked buffer, each segment size will be <see cref="F:NLiblet.IO.ByteArraySegmentsStream._allocationSize" />.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._capacity">
      <summary>
            	Sum of lengths of all segments in <see cref="F:NLiblet.IO.ByteArraySegmentsStream._buffer" /> to avoid costly sumuation.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._allocationSize">
      <summary>
            	User specified allocation size.
            	At least, it is necessary for testing.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._length">
      <summary>
            	Total length of stream, that is lengths of effective segments.
            	This field is necessary to avoid costly calculation.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._lastUsedSegmentIndex">
      <summary>
            	Index of last segment of effective segments on <see cref="F:NLiblet.IO.ByteArraySegmentsStream._buffer" />.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._offsetInLastSegment">
      <summary>
            	Index of last effective element of last effective segment on <see cref="F:NLiblet.IO.ByteArraySegmentsStream._buffer" />.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._position">
      <summary>
            	Current position of this stream to avoid costly calculation.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._currentSegmentIndex">
      <summary>
            	Index of current segment on <see cref="F:NLiblet.IO.ByteArraySegmentsStream._buffer" />.
            	This value always valid.
            </summary>
    </member>
    <member name="F:NLiblet.IO.ByteArraySegmentsStream._offsetInCurrentSegment">
      <summary>
            	Index of element of current segment of <see cref="F:NLiblet.IO.ByteArraySegmentsStream._buffer" />.
            	This value will be invalid to indicate that this stream position is in tail.
            </summary>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.#ctor">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.IO.ByteArraySegmentsStream" /> class with default capacity.
            </summary>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.#ctor(System.Int64)">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.IO.ByteArraySegmentsStream" /> class with specified capacity.
            </summary>
      <param name="initialCapacity">The initial capacity of backing store.</param>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.#ctor(System.Int64,System.Int32)">
      <summary>
            	Testing purpose only.
            	Initializes a new instance of the <see cref="T:NLiblet.IO.ByteArraySegmentsStream" /> class.
            </summary>
      <param name="initialCapacity">The initial capacity of backing store.</param>
      <param name="allocationSize">Size of the allocation of backing store.</param>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Dispose(System.Boolean)">
      <summary>
            		Releases the unmanaged resources used by the <see cref="T:System.IO.Stream" /> 
            		and optionally releases the managed resources. 
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources;
            	<c>false</c> to release only unmanaged resources.
            </param>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.AssertInternalInvariant">
      <summary>
            	Assert internal invariant on debug build.
            </summary>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Flush">
      <summary>
            	Overrides <see cref="M:System.IO.Stream.Flush" /> so that no action is performed.
            </summary>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            	Sets the position within the current stream to the specified value.
            </summary>
      <param name="offset">
            	The new position within the stream. 
            	This is relative to the <paramref name="origin" /> parameter, and can be positive or negative. 
            </param>
      <param name="origin">
            	A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point. 
            </param>
      <returns>
            	The new position within the stream, calculated by combining the initial reference point and the offset.
            </returns>
      <exception cref="T:System.IO.IOException">
            	Destination position will be lessor than 0.
            </exception>
      <exception cref="T:System.NotSupportedException">
            	Destination position will be greator than <see cref="F:System.Int32.MaxValue" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Back(System.Int64)">
      <summary>
            	Moves position backwardly.
            </summary>
      <param name="offsetFromCurrent">Offset from current position. This value must be negative.</param>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Forward(System.Int64)">
      <summary>
            	Moves position forwardly.
            </summary>
      <param name="offsetFromCurrent" />
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.EnsureAllocated(System.Int64)">
      <summary>
            	Ensure required sized buffer is allocated.
            	If there is not enough size then new segments will be allocated.
            </summary>
      <param name="requiredSize" />
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Expand(System.Int64)">
      <summary>
            	Expand (i.e. allocate) buffer to satisfy specified size.
            </summary>
      <param name="requiredSize">Required buffer size to be allocated.</param>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.SetLength(System.Int64)">
      <summary>
            	Sets the length of the current stream to the specified value.
            </summary>
      <param name="value">
            	The value at which to set the length. 
            </param>
      <exception cref="T:System.NotSupportedException">
            	Length will be greator than <see cref="F:System.Int32.MaxValue" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <requires inheritedFrom="M:System.IO.Stream.SetLength(System.Int64)" inheritedFromTypeName="Stream">value &gt;= 0</requires>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            	Reads a block of bytes from the current stream and writes the data to <paramref name="buffer" />.
            </summary>
      <param name="buffer">
            	When this method returns, contains the specified byte array 
            	with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) 
            	replaced by the characters read from the current stream. 
            </param>
      <param name="offset">
            	The byte offset in <paramref name="buffer" /> at which to begin reading. 
            </param>
      <param name="count">
            	The maximum number of bytes to read. 
            </param>
      <returns>
            	The total number of bytes written into the buffer. 
            	This can be less than the number of bytes requested if that number of bytes are not currently available, 
            	or zero if the end of the stream is reached before any bytes are read. 
            </returns>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <remarks>
            	This method causes byte array copying.
            </remarks>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream"> count &lt;= (buffer.Length - offset)</requires>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &lt;= count</ensures>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Read(System.Int32)">
      <summary>
            	Reads a block of bytes from the current stream as list of <see cref="T:System.ArraySegment`1" /> of byte.
            </summary>
      <param name="count">
            	The maximum number of bytes to read. 
            </param>
      <returns>
            	List of <see cref="T:System.ArraySegment`1" />.
            	Each segment represents a piece of read buffer.
            	The total length can be less than the number of bytes requested 
            	if that number of bytes are not currently available, 
            	or zero if the end of the stream is reached before any bytes are read. 
            </returns>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <remarks>
            	This method does not cause byte copying.
            	<note>
            		You should not modify contents of <see cref="P:System.ArraySegment`1.Array" />,
            		because it causes unexpected behavior when multiple consumer uses underlying stream.
            	</note></remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; count </exception>
      <ensures> Contract.Result&lt;IList&lt;ArraySegment&lt;byte&gt;&gt;&gt;() != null </ensures>
      <ensures> Contract.Result&lt;IList&lt;ArraySegment&lt;byte&gt;&gt;&gt;().Sum( item =&gt; item.Count ) &lt;= count </ensures>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.ReadByte">
      <summary>
            	Reads a byte from the current stream.
            </summary>
      <returns>
            	The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.
            </returns>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <ensures inheritedFrom="M:System.IO.Stream.ReadByte" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            	Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
      <param name="buffer">
            	An array of bytes. 
            	This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream. 
            </param>
      <param name="offset">
            	The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream. 
            </param>
      <param name="count">
            	The number of bytes to be written to the current stream. 
            </param>
      <exception cref="T:System.NotSupportedException">
            	Length will be greator than <see cref="F:System.Int32.MaxValue" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <remarks>
            	This method causes byte array copying.
            </remarks>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &lt;= (buffer.Length - offset)</requires>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.WriteToCurrentSegment(System.Byte[],System.Int32@,System.Int32@)">
      <summary>
            	Write data to current segment.
            </summary>
      <param name="buffer">Buffer.</param>
      <param name="offset">Offset reference. This value will be incremented.</param>
      <param name="count">Count reference. This value will be decremented.</param>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.WriteByte(System.Byte)">
      <summary>
            	Writes a byte to the current stream at the current position.
            </summary>
      <param name="value">
            	The byte to write. 
            </param>
      <exception cref="T:System.NotSupportedException">
            	Length will be greator than <see cref="F:System.Int32.MaxValue" />.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Insert(System.Byte[],System.Int32,System.Int32)">
      <summary>
            	Insert specifid bytes to current position without copying.
            </summary>
      <param name="value">
            	Bytes to be inserted.
            </param>
      <param name="offset">
            	The zero-based byte offset in <paramref name="value" /> at which to begin copying bytes to the current stream. 
            </param>
      <param name="count">
            	The number of bytes to be written to the current stream. 
            </param>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <remarks>
            	This method does not cause byte copying.
            	<note>
            		You should not modify contents of <see cref="T:System.Byte" />[],
            		because it causes unexpected behavior when multiple consumer uses underlying stream.
            	</note></remarks>
      <requires exception="T:System.IO.IOException"> this.Length + count &lt; Int32.MaxValue </requires>
      <exception cref="T:System.IO.IOException"> this.Length + count &gt;= Int32.MaxValue </exception>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.Insert(System.ArraySegment{System.Byte})">
      <summary>
            	Insert specifid bytes to current position without copying.
            </summary>
      <param name="value">
            	Bytes to be inserted.
            </param>
      <exception cref="T:System.ObjectDisposedException">
            	The current stream instance is closed.
            </exception>
      <remarks>
            	This method does not cause byte copying.
            	<note>
            		You should not modify contents of <see cref="T:System.ArraySegment`1" />,
            		because it causes unexpected behavior when multiple consumer uses underlying stream.
            	</note></remarks>
      <requires exception="T:System.IO.IOException"> this.Length + value.Count &lt; Int32.MaxValue </requires>
      <exception cref="T:System.IO.IOException"> this.Length + value.Count &gt;= Int32.MaxValue </exception>
    </member>
    <member name="M:NLiblet.IO.ByteArraySegmentsStream.AsList">
      <summary>
            	Writes the stream contents to a list of <see cref="T:System.ArraySegment`1" />, regardless of the <see cref="P:NLiblet.IO.ByteArraySegmentsStream.Position" /> property.
            </summary>
      <returns>A new list of <see cref="T:System.ArraySegment`1" />.</returns>
      <remarks>
            	Actual type of return value might be changed in the future.
            </remarks>
      <pure />
    </member>
    <member name="P:NLiblet.IO.ByteArraySegmentsStream.CanRead">
      <summary>
            	Gets a value indicating whether the current stream supports reading.
            </summary>
      <value>Always <c>true</c>.</value>
    </member>
    <member name="P:NLiblet.IO.ByteArraySegmentsStream.CanSeek">
      <summary>
            	Gets a value indicating whether the current stream supports seeking.
            </summary>
      <value>Always <c>true</c>.</value>
    </member>
    <member name="P:NLiblet.IO.ByteArraySegmentsStream.CanWrite">
      <summary>
            	Gets a value indicating whether the current stream supports writing.
            </summary>
      <value>Always <c>true</c>.</value>
    </member>
    <member name="P:NLiblet.IO.ByteArraySegmentsStream.Length">
      <summary>
            	Gets the length in bytes of the stream.
            </summary>
      <value>
            	A long value representing the length of the stream in bytes.
            	It equals to sum of each <see cref="P:System.ArraySegment`1.Count" /> of return value of <see cref="M:NLiblet.IO.ByteArraySegmentsStream.AsList" />.
            </value>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Length" inheritedFromTypeName="Stream">Contract.Result&lt;long&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:NLiblet.IO.ByteArraySegmentsStream.Position">
      <summary>
            	Gets or sets the position within the current stream.
            </summary>
      <value>
            	The current position within the stream.
            </value>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Position" inheritedFromTypeName="Stream">Contract.Result&lt;Int64&gt;() &gt;= 0</ensures>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.IO.Stream.set_Position(System.Int64)" inheritedFromTypeName="Stream">value &gt;= 0</requires>
      </setter>
    </member>
    <member name="T:NLiblet.IO.EnumerableStream">
      <summary>
            	Wrap <see cref="T:System.Collections.Generic.IEnumerable`1">IEnumerable</see>&lt;<see cref="T:System.Byte" />&gt; as read-only <see cref="T:System.IO.Stream" />.
            </summary>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.#ctor(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            Initializes a new instance of the <see cref="T:NLiblet.IO.EnumerableStream" /> class.
            </summary>
      <param name="source">The source collection.</param>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.Dispose(System.Boolean)">
      <summary>
            	Releases the unmanaged resources used by the <see cref="T:NLiblet.IO.EnumerableStream" /> class and optionally releases the managed resources.
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.
            </param>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.Flush">
      <summary>
            	No operation will be executed.
            </summary>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            	Reads a sequence of bytes from the underlying stream and advances the position within the stream by the number of bytes read.
            </summary>
      <param name="buffer">
            	An array of bytes. 
            	When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source. 
            	</param>
      <param name="offset">
            	The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream. 
            </param>
      <param name="count">
            	The maximum number of bytes to be read from the current stream. 
            </param>
      <returns>
            	The total number of bytes read into the buffer. 
            	This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached. 
            </returns>
      <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream"> count &lt;= (buffer.Length - offset)</requires>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &lt;= count</ensures>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.ReadByte">
      <summary>
            	Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
            </summary>
      <returns>
            	The unsigned byte cast to an <see cref="T:System.Int32" />, or -1 if at the end of the stream.
            </returns>
      <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
      <ensures inheritedFrom="M:System.IO.Stream.ReadByte" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            	Sets the position within the current stream.
            </summary>
      <param name="offset">A byte offset relative to the origin parameter. </param>
      <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position. </param>
      <returns>The new position within the current stream.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            	Resulting position will exceed underlying array length.
            </exception>
      <exception cref="T:System.NotSupportedException">
            	The stream does not support seeking, because source is not array of byte.
            </exception>
      <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed. 
            </exception>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.SetLength(System.Int64)">
      <summary>
            	Always throws <see cref="T:System.NotSupportedException" />.
            </summary>
      <param name="value">Ignored.</param>
      <exception cref="T:System.NotSupportedException">Always thrown.</exception>
      <requires inheritedFrom="M:System.IO.Stream.SetLength(System.Int64)" inheritedFromTypeName="Stream">value &gt;= 0</requires>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            	Always throws <see cref="T:System.NotSupportedException" />.
            </summary>
      <param name="buffer">Ignored.</param>
      <param name="offset">Ignored.</param>
      <param name="count">Ignored.</param>
      <exception cref="T:System.NotSupportedException">Always thrown.</exception>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &lt;= (buffer.Length - offset)</requires>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.CanRead">
      <summary>
            	Gets a value indicating whether the current stream supports reading.
            </summary>
      <value>Always <c>true</c>.</value>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.CanSeek">
      <summary>
            	Gets a value indicating whether the current stream supports seeking.
            </summary>
      <value>
        <c>true</c> if the underlying collection is array; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.CanWrite">
      <summary>
            	Gets a value indicating whether the current stream supports writing.
            </summary>
      <value>Always <c>false</c>.</value>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.Length">
      <summary>
            	Gets the length in bytes of the stream.
            </summary>
      <value>
            	A long value representing the length of the stream in bytes.
            </value>
      <exception cref="T:System.NotSupportedException">
            	The underlying collection is not array.
            </exception>
      <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Length" inheritedFromTypeName="Stream">Contract.Result&lt;long&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.Position">
      <summary>
            	Gets the position within the current stream.
            </summary>
      <value>
            	The current position within the stream.
            </value>
      <exception cref="T:System.NotSupportedException">
            	The underlying collection is not array.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            	Resulting position will exceed underlying array length.
            </exception>
      <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Position" inheritedFromTypeName="Stream">Contract.Result&lt;Int64&gt;() &gt;= 0</ensures>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.IO.Stream.set_Position(System.Int64)" inheritedFromTypeName="Stream">value &gt;= 0</requires>
      </setter>
    </member>
    <member name="T:NLiblet.Pair`2">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`2._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`2._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`2.#ctor(`0,`1)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
    </member>
    <member name="M:NLiblet.Pair`2.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`2.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`2.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`2" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`2" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`2.Equals(NLiblet.Pair{`0,`1})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`2" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`2.op_Equality(NLiblet.Pair{`0,`1},NLiblet.Pair{`0,`1})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`2" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`2" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`2.op_Inequality(NLiblet.Pair{`0,`1},NLiblet.Pair{`0,`1})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`2" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`2" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`2.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`2.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`2.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="T:NLiblet.Pair`3">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`3._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`3._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`3._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`3.#ctor(`0,`1,`2)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
    </member>
    <member name="M:NLiblet.Pair`3.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`3.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`3.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`3" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`3" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`3.Equals(NLiblet.Pair{`0,`1,`2})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`3" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`3.op_Equality(NLiblet.Pair{`0,`1,`2},NLiblet.Pair{`0,`1,`2})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`3" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`3" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`3.op_Inequality(NLiblet.Pair{`0,`1,`2},NLiblet.Pair{`0,`1,`2})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`3" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`3" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`3.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`3.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`3.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`3.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="T:NLiblet.Pair`4">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`4._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`4._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`4._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`4._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`4.#ctor(`0,`1,`2,`3)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
    </member>
    <member name="M:NLiblet.Pair`4.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`4.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`4.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`4" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`4" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`4.Equals(NLiblet.Pair{`0,`1,`2,`3})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`4" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`4.op_Equality(NLiblet.Pair{`0,`1,`2,`3},NLiblet.Pair{`0,`1,`2,`3})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`4" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`4" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`4.op_Inequality(NLiblet.Pair{`0,`1,`2,`3},NLiblet.Pair{`0,`1,`2,`3})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`4" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`4" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`4.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`4.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`4.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`4.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`4.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="T:NLiblet.Pair`5">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`5._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`5._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`5._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`5._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`5._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`5.#ctor(`0,`1,`2,`3,`4)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
    </member>
    <member name="M:NLiblet.Pair`5.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`5.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`5.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`5" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`5" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`5.Equals(NLiblet.Pair{`0,`1,`2,`3,`4})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`5" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`5.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4},NLiblet.Pair{`0,`1,`2,`3,`4})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`5" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`5" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`5.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4},NLiblet.Pair{`0,`1,`2,`3,`4})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`5" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`5" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`5.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`5.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`5.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`5.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`5.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`5.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="T:NLiblet.Pair`6">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`6._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`6._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`6._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`6._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`6._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`6._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`6.#ctor(`0,`1,`2,`3,`4,`5)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
    </member>
    <member name="M:NLiblet.Pair`6.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`6.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`6.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`6" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`6" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`6.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`6" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`6.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5},NLiblet.Pair{`0,`1,`2,`3,`4,`5})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`6" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`6" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`6.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5},NLiblet.Pair{`0,`1,`2,`3,`4,`5})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`6" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`6" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`6.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`6.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`6.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`6.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`6.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`6.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`6.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="T:NLiblet.Pair`7">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`7._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
    </member>
    <member name="M:NLiblet.Pair`7.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`7.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`7.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`7" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`7" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`7.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`7" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`7.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`7" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`7" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`7.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`7" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`7" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`7.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`7.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`7.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`7.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`7.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`7.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`7.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`7.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="T:NLiblet.Pair`8">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`8._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
    </member>
    <member name="M:NLiblet.Pair`8.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`8.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`8.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`8" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`8" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`8.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`8" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`8.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`8" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`8" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`8.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`8" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`8" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`8.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`8.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`8.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="T:NLiblet.Pair`9">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`9._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`9.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
    </member>
    <member name="M:NLiblet.Pair`9.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`9.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`9.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`9" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`9" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`9.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`9" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`9.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`9" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`9" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`9.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`9" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`9" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`9.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`9.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`9.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="T:NLiblet.Pair`10">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`10._item10">
      <summary>
            	The item of #10.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`10.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
      <param name="item10">
            	The item of #10.
            </param>
    </member>
    <member name="M:NLiblet.Pair`10.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`10.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`10.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`10" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`10" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`10.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`10" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`10.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`10" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`10" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`10.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`10" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`10" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`10.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`10.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="P:NLiblet.Pair`10.Item10">
      <summary>
            	Get the item of #10.
            </summary>
      <value>
            	The item of #10.
            </value>
    </member>
    <member name="T:NLiblet.Pair`11">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item10">
      <summary>
            	The item of #10.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`11._item11">
      <summary>
            	The item of #11.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`11.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
      <param name="item10">
            	The item of #10.
            </param>
      <param name="item11">
            	The item of #11.
            </param>
    </member>
    <member name="M:NLiblet.Pair`11.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`11.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`11.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`11" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`11" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`11.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`11" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`11.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`11" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`11" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`11.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`11" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`11" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`11.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`11.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item10">
      <summary>
            	Get the item of #10.
            </summary>
      <value>
            	The item of #10.
            </value>
    </member>
    <member name="P:NLiblet.Pair`11.Item11">
      <summary>
            	Get the item of #11.
            </summary>
      <value>
            	The item of #11.
            </value>
    </member>
    <member name="T:NLiblet.Pair`12">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item10">
      <summary>
            	The item of #10.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item11">
      <summary>
            	The item of #11.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`12._item12">
      <summary>
            	The item of #12.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`12.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
      <param name="item10">
            	The item of #10.
            </param>
      <param name="item11">
            	The item of #11.
            </param>
      <param name="item12">
            	The item of #12.
            </param>
    </member>
    <member name="M:NLiblet.Pair`12.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`12.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`12.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`12" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`12" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`12.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`12" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`12.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`12" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`12" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`12.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`12" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`12" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`12.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`12.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item10">
      <summary>
            	Get the item of #10.
            </summary>
      <value>
            	The item of #10.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item11">
      <summary>
            	Get the item of #11.
            </summary>
      <value>
            	The item of #11.
            </value>
    </member>
    <member name="P:NLiblet.Pair`12.Item12">
      <summary>
            	Get the item of #12.
            </summary>
      <value>
            	The item of #12.
            </value>
    </member>
    <member name="T:NLiblet.Pair`13">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item10">
      <summary>
            	The item of #10.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item11">
      <summary>
            	The item of #11.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item12">
      <summary>
            	The item of #12.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`13._item13">
      <summary>
            	The item of #13.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`13.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
      <param name="item10">
            	The item of #10.
            </param>
      <param name="item11">
            	The item of #11.
            </param>
      <param name="item12">
            	The item of #12.
            </param>
      <param name="item13">
            	The item of #13.
            </param>
    </member>
    <member name="M:NLiblet.Pair`13.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`13.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`13.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`13" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`13" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`13.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`13" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`13.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`13" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`13" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`13.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`13" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`13" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`13.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`13.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item10">
      <summary>
            	Get the item of #10.
            </summary>
      <value>
            	The item of #10.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item11">
      <summary>
            	Get the item of #11.
            </summary>
      <value>
            	The item of #11.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item12">
      <summary>
            	Get the item of #12.
            </summary>
      <value>
            	The item of #12.
            </value>
    </member>
    <member name="P:NLiblet.Pair`13.Item13">
      <summary>
            	Get the item of #13.
            </summary>
      <value>
            	The item of #13.
            </value>
    </member>
    <member name="T:NLiblet.Pair`14">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item10">
      <summary>
            	The item of #10.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item11">
      <summary>
            	The item of #11.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item12">
      <summary>
            	The item of #12.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item13">
      <summary>
            	The item of #13.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`14._item14">
      <summary>
            	The item of #14.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`14.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
      <param name="item10">
            	The item of #10.
            </param>
      <param name="item11">
            	The item of #11.
            </param>
      <param name="item12">
            	The item of #12.
            </param>
      <param name="item13">
            	The item of #13.
            </param>
      <param name="item14">
            	The item of #14.
            </param>
    </member>
    <member name="M:NLiblet.Pair`14.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`14.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`14.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`14" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`14" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`14.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`14" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`14.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`14" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`14" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`14.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`14" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`14" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`14.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`14.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item10">
      <summary>
            	Get the item of #10.
            </summary>
      <value>
            	The item of #10.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item11">
      <summary>
            	Get the item of #11.
            </summary>
      <value>
            	The item of #11.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item12">
      <summary>
            	Get the item of #12.
            </summary>
      <value>
            	The item of #12.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item13">
      <summary>
            	Get the item of #13.
            </summary>
      <value>
            	The item of #13.
            </value>
    </member>
    <member name="P:NLiblet.Pair`14.Item14">
      <summary>
            	Get the item of #14.
            </summary>
      <value>
            	The item of #14.
            </value>
    </member>
    <member name="T:NLiblet.Pair`15">
      <summary>
            	Represents pair of values.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item1">
      <summary>
            	The item of #1.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item2">
      <summary>
            	The item of #2.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item3">
      <summary>
            	The item of #3.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item4">
      <summary>
            	The item of #4.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item5">
      <summary>
            	The item of #5.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item6">
      <summary>
            	The item of #6.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item7">
      <summary>
            	The item of #7.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item8">
      <summary>
            	The item of #8.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item9">
      <summary>
            	The item of #9.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item10">
      <summary>
            	The item of #10.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item11">
      <summary>
            	The item of #11.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item12">
      <summary>
            	The item of #12.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item13">
      <summary>
            	The item of #13.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item14">
      <summary>
            	The item of #14.
            </summary>
    </member>
    <member name="F:NLiblet.Pair`15._item15">
      <summary>
            	The item of #15.
            </summary>
    </member>
    <member name="M:NLiblet.Pair`15.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="item1">
            	The item of #1.
            </param>
      <param name="item2">
            	The item of #2.
            </param>
      <param name="item3">
            	The item of #3.
            </param>
      <param name="item4">
            	The item of #4.
            </param>
      <param name="item5">
            	The item of #5.
            </param>
      <param name="item6">
            	The item of #6.
            </param>
      <param name="item7">
            	The item of #7.
            </param>
      <param name="item8">
            	The item of #8.
            </param>
      <param name="item9">
            	The item of #9.
            </param>
      <param name="item10">
            	The item of #10.
            </param>
      <param name="item11">
            	The item of #11.
            </param>
      <param name="item12">
            	The item of #12.
            </param>
      <param name="item13">
            	The item of #13.
            </param>
      <param name="item14">
            	The item of #14.
            </param>
      <param name="item15">
            	The item of #15.
            </param>
    </member>
    <member name="M:NLiblet.Pair`15.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Pair`15.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`15.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.Pair`15" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.Pair`15" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`15.Equals(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.Pair`15" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`15.op_Equality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`15" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`15" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.Pair`15.op_Inequality(NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14},NLiblet.Pair{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14})">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.Pair`15" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.Pair`15" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.Pair`15.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.Pair`15.Item1">
      <summary>
            	Get the item of #1.
            </summary>
      <value>
            	The item of #1.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item2">
      <summary>
            	Get the item of #2.
            </summary>
      <value>
            	The item of #2.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item3">
      <summary>
            	Get the item of #3.
            </summary>
      <value>
            	The item of #3.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item4">
      <summary>
            	Get the item of #4.
            </summary>
      <value>
            	The item of #4.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item5">
      <summary>
            	Get the item of #5.
            </summary>
      <value>
            	The item of #5.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item6">
      <summary>
            	Get the item of #6.
            </summary>
      <value>
            	The item of #6.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item7">
      <summary>
            	Get the item of #7.
            </summary>
      <value>
            	The item of #7.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item8">
      <summary>
            	Get the item of #8.
            </summary>
      <value>
            	The item of #8.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item9">
      <summary>
            	Get the item of #9.
            </summary>
      <value>
            	The item of #9.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item10">
      <summary>
            	Get the item of #10.
            </summary>
      <value>
            	The item of #10.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item11">
      <summary>
            	Get the item of #11.
            </summary>
      <value>
            	The item of #11.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item12">
      <summary>
            	Get the item of #12.
            </summary>
      <value>
            	The item of #12.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item13">
      <summary>
            	Get the item of #13.
            </summary>
      <value>
            	The item of #13.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item14">
      <summary>
            	Get the item of #14.
            </summary>
      <value>
            	The item of #14.
            </value>
    </member>
    <member name="P:NLiblet.Pair`15.Item15">
      <summary>
            	Get the item of #15.
            </summary>
      <value>
            	The item of #15.
            </value>
    </member>
    <member name="T:NLiblet.Properties.Resources">
      <summary>
              ローカライズされた文字列などを検索するための、厳密に型指定されたリソース クラスです。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.ResourceManager">
      <summary>
              このクラスで使用されているキャッシュされた ResourceManager インスタンスを返します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Culture">
      <summary>
              厳密に型指定されたこのリソース クラスを使用して、すべての検索リソースに対し、
              現在のスレッドの CurrentUICulture プロパティをオーバーライドします。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.BytearraySegmentsStream_CannotBeBeforeHead">
      <summary>
              Cannot move to before position 0. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.BytearraySegmentsStream_LengthCannotBeGratorThanInt32MaxValue">
      <summary>
              Length cannot be greator than Int32.MaxValue. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.BytearraySegmentsStream_OffsetCannotBeGratorThanInt32MaxValue">
      <summary>
              offset cannot be greator than Int32.MaxValue. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.BytearraySegmentsStream_RequiredSizeIsTooLarge">
      <summary>
              Required size is too large. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.CastCode_CannotCastArrayItemAt">
      <summary>
              Cannot cast array item at {0}. Cannot cast '{1}' type instance to '{2}' type. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.CastCode_CannotCastArrayItemWithTypeConverterAt">
      <summary>
              Cannot cast array item at {0}. Cannot cast '{1}' type instance to '{2}' type with TypeConverter '{3}'. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.CastCode_CannotCastWithTypeConverter">
      <summary>
              Cannot cast '{0}' type instance to '{1}' type with TypeConverter '{2}'. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.CastCode_UnknownPrimitive">
      <summary>
              Unknown primitive type '{0}'. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Error_InputHexCharacterSequenceIsEndUnexpctedly">
      <summary>
              Input sequence ended unexpctedly at position {0:###,0}. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Error_InvalidCodePoint">
      <summary>
              Invalid code point : 0x{0:x4} に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Error_InvalidHexCharacter">
      <summary>
              Character '{0:m}'(\\u{0:x}, {0:c}) at position {1:###,0} is invalid as hexadecimal. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Formatter_UnexpectedType">
      <summary>
              Type '{0}' is unexpected. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Formatter_UnknownFormat">
      <summary>
              Unknown format '{0}'. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.GeneratedCodeHelper_CannotResolveOverload">
      <summary>
              Cannot resolve overload between '{0}'. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.GeneratedCodeHelper_ValueTypeArgumentCannotBeNull">
      <summary>
              Type of argument at {0} is value type ({1}), so it cannot be null. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.MethodInfoExtensions_TooManyParameters">
      <summary>
              There are too many parameters for method '[{0}]{1}::{2}'. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Reflection_CustomMethodBaseIsNotSupported">
      <summary>
              '{0}' is not supported. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Properties.Resources.Reflection_TypeInitializerIsNotSupported">
      <summary>
              Type initializer (also known as static constructor or class initializer) is not supported. に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="F:NLiblet.CastingTypePair._source">
      <summary>
        <see cref="T:System.RuntimeTypeHandle" /> of cast source.
            </summary>
    </member>
    <member name="F:NLiblet.CastingTypePair._target">
      <summary>
        <see cref="T:System.RuntimeTypeHandle" /> of cast target.
            </summary>
    </member>
    <member name="M:NLiblet.CastingTypePair.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
      <summary>
            	Initialize new instance.
            </summary>
      <param name="source">
        <see cref="T:System.RuntimeTypeHandle" /> of cast source.
            </param>
      <param name="target">
        <see cref="T:System.RuntimeTypeHandle" /> of cast target.
            </param>
    </member>
    <member name="M:NLiblet.CastingTypePair.ToString">
      <summary>
            	Returns string representation of this instnace.
            </summary>
      <returns>
            	String representation of this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.CastingTypePair.GetHashCode">
      <summary>
            	Returns hash code of this instnace.
            </summary>
      <returns>
            	Hash code of this instance.
            </returns>
    </member>
    <member name="M:NLiblet.CastingTypePair.Equals(System.Object)">
      <summary>
            	Compare specified object is <see cref="T:NLiblet.CastingTypePair" /> and equal to this instnace.
            </summary>
      <param name="obj">
        <see cref="T:NLiblet.CastingTypePair" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.CastingTypePair.Equals(NLiblet.CastingTypePair)">
      <summary>
            	Compare specified object is equal to this instnace.
            </summary>
      <param name="other">
        <see cref="T:NLiblet.CastingTypePair" /> to compare.
            </param>
      <returns>
            	If specified instance equals to this instance then true.
            </returns>
    </member>
    <member name="M:NLiblet.CastingTypePair.op_Equality(NLiblet.CastingTypePair,NLiblet.CastingTypePair)">
      <summary>
            	Compare specified two objects are equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.CastingTypePair" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.CastingTypePair" /> to compare.
            </param>
      <returns>
            	If specified objects are equal then true.
            </returns>
    </member>
    <member name="M:NLiblet.CastingTypePair.op_Inequality(NLiblet.CastingTypePair,NLiblet.CastingTypePair)">
      <summary>
            	Compare specified two objects are not equal.
            </summary>
      <param name="left">
        <see cref="T:NLiblet.CastingTypePair" /> to compare.
            </param>
      <param name="right">
        <see cref="T:NLiblet.CastingTypePair" /> to compare.
            </param>
      <returns>
            	If specified objects are not equal then true.
            </returns>
    </member>
    <member name="P:NLiblet.CastingTypePair.Null">
      <summary>
            	Get empty instance.
            </summary>
    </member>
    <member name="P:NLiblet.CastingTypePair.Source">
      <summary>
            	Get <see cref="T:System.RuntimeTypeHandle" /> of cast source.
            </summary>
      <value>
        <see cref="T:System.RuntimeTypeHandle" /> of cast source.
            </value>
    </member>
    <member name="P:NLiblet.CastingTypePair.Target">
      <summary>
            	Get <see cref="T:System.RuntimeTypeHandle" /> of cast target.
            </summary>
      <value>
        <see cref="T:System.RuntimeTypeHandle" /> of cast target.
            </value>
    </member>
    <member name="T:NLiblet.Reflection.GenericTypeExtensions">
      <summary>
            	Define utility extension method for generic type.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.Inherits(System.Type,System.Type)">
      <summary>
            	Determine whether the source type inherits directly or indirectly from specified generic type or its built type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericType">Generic type.</param>
      <returns>
        <c>true</c> if <paramref name="source" />, directly or indirectly, inherits from <paramref name="genericType" />,
            	or built closed generic type;
            	otherwise <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentNullException"> genericType != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericType == null </exception>
      <requires exception="T:System.ArgumentNullException"> !genericType.IsInterface </requires>
      <exception cref="T:System.ArgumentNullException">!( !genericType.IsInterface )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.ElementInherits(System.Type,System.Type)">
      <summary>
            	Determine whether the element type of the source array type inherits directly or indirectly from specified generic type or its built type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericType">Generic type.</param>
      <returns>
        <c>true</c> if the elements of <paramref name="source" />, directly or indirectly, inherits from <paramref name="genericType" />,
            	or built closed generic type;
            	otherwise <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.InvalidOperationException"> source.IsArray </requires>
      <exception cref="T:System.InvalidOperationException">!( source.IsArray )</exception>
      <requires exception="T:System.ArgumentNullException"> genericType != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericType == null </exception>
      <requires exception="T:System.ArgumentNullException"> !genericType.IsInterface </requires>
      <exception cref="T:System.ArgumentNullException">!( !genericType.IsInterface )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.Implements(System.Type,System.Type)">
      <summary>
            	Determine whether the source type implements specified generic type or its built type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericType">Generic interface type.</param>
      <returns>
        <c>true</c> if <paramref name="source" /> implements <paramref name="genericType" />,
            	or built closed generic interface type;
            	otherwise <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentNullException"> genericType != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericType == null </exception>
      <requires exception="T:System.ArgumentException"> genericType.IsInterface </requires>
      <exception cref="T:System.ArgumentException">!( genericType.IsInterface )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.ElementImplements(System.Type,System.Type)">
      <summary>
            	Determine whether the element type of the source array type implements specified generic type or its built type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericType">Generic interface type.</param>
      <returns>
        <c>true</c> if the elements of <paramref name="source" /> implements <paramref name="genericType" />,
            	or built closed generic interface type;
            	otherwise <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.InvalidOperationException"> source.IsArray </requires>
      <exception cref="T:System.InvalidOperationException">!( source.IsArray )</exception>
      <requires exception="T:System.ArgumentNullException"> genericType != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericType == null </exception>
      <requires exception="T:System.ArgumentException"> genericType.IsInterface </requires>
      <exception cref="T:System.ArgumentException">!( genericType.IsInterface )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.FindGenericTypes(System.Type,System.Type)">
      <summary>
            	Gets the generic types which is specified generic type or its built type, which are implemented or inherited by source type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericType">Generic type.</param>
      <returns>
            	If <paramref name="source" /> has closed built type of, inhertis, or implements <paramref name="genericType" />or its closed type,
            	returns these types.
            	otherwise empty array.
            </returns>
      <remarks>
            	If <paramref name="source" /> is generic type definition, then return types are generic type definitions.
            	Else return types are not generic type definitions, but might not be closed generic type when in the generic method.
            </remarks>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentNullException"> genericType != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericType == null </exception>
      <requires exception="T:System.ArgumentException"> genericType.IsGenericType </requires>
      <exception cref="T:System.ArgumentException">!( genericType.IsGenericType )</exception>
      <ensures> Contract.Result&lt;Type[]&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.FindElementGenericTypes(System.Type,System.Type)">
      <summary>
            	Gets the generic types which is specified generic type or its built type, which are implemented or inherited by the element type of source array type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericType">Generic type.</param>
      <returns>
            	If <paramref name="source" /> has closed built type of, inhertis, or implements <paramref name="genericType" />or its closed type,
            	returns these types.
            	otherwise empty array.
            </returns>
      <remarks>
            	Return types are not generic type definitions, but might not be closed generic type when in the generic method.
            </remarks>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.InvalidOperationException"> source.IsArray </requires>
      <exception cref="T:System.InvalidOperationException">!( source.IsArray )</exception>
      <requires exception="T:System.ArgumentNullException"> genericType != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericType == null </exception>
      <requires exception="T:System.ArgumentException"> genericType.IsGenericType </requires>
      <exception cref="T:System.ArgumentException">!( genericType.IsGenericType )</exception>
      <ensures> Contract.Result&lt;Type[]&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.IsClosedTypeOf(System.Type,System.Type)">
      <summary>
            	Determine whether source type is closed generic type for specified open generic type (a.k.a. generic type definition).
            </summary>
      <param name="source">Target type.</param>
      <param name="genericTypeDefinition">Generic type definition.</param>
      <returns>
        <c>true</c> if <paramref name="source" /> is closed type built from <paramref name="genericTypeDefinition" />,
            	otherwise <c>false</c>.
            	When <paramref name="source" /> is not generic type or is generic type definition then <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentNullException"> genericTypeDefinition != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericTypeDefinition == null </exception>
      <requires exception="T:System.ArgumentException"> genericTypeDefinition.IsGenericTypeDefinition </requires>
      <exception cref="T:System.ArgumentException">!( genericTypeDefinition.IsGenericTypeDefinition )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.GetName(System.Type)">
      <summary>
            	Get name of type without namespace and assembly name of itself and its generic arguments.
            </summary>
      <param name="source">Target type.</param>
      <returns>Simple name of type.</returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.GetFullName(System.Type)">
      <summary>
            	Get full name of type including namespace and excluding assembly name of itself and its generic arguments.
            </summary>
      <param name="source">Target type.</param>
      <returns>Full name of type.</returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="T:NLiblet.Reflection.ILAssemblyLanguage">
      <summary>
            	Define utility methods related to the IL Assembly language.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.ILAssemblyLanguage.IsValidId(System.String)">
      <summary>
            	Determines specified string is valid as ID of ECMA-CLI IL-Asm ID.
            </summary>
      <param name="value">Value to be determined.</param>
      <returns>If <paramref name="value" /> is valid ID then <c>true</c>; otherwise <c>false</c>.</returns>
      <pure />
    </member>
    <member name="T:NLiblet.Reflection.Invoker">
      <summary>
            	Provides weak typed method invocation features without <see cref="T:System.Reflection.TargetInvocationException" />.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateActionInvoker(System.Reflection.MethodInfo)">
      <summary>
            	Create <see cref="T:System.Action`2" /> as invoker without host type nor skipping visibility.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" /> which does not have return value.</param>
      <returns>
        <see cref="T:System.Action`2" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> target.IsPublic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsPublic )</exception>
      <requires exception="T:System.ArgumentException"> target.ReturnType == typeof( void ) </requires>
      <exception cref="T:System.ArgumentException">!( target.ReturnType == typeof( void ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateActionInvoker(System.Reflection.MethodInfo,System.Boolean)">
      <summary>
            	Create <see cref="T:System.Action`2" /> as invoker without host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" /> which does not have return value.</param>
      <param name="restrictedSkipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <returns>
        <see cref="T:System.Action`2" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> target.IsPublic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsPublic )</exception>
      <requires exception="T:System.ArgumentException"> target.ReturnType == typeof( void ) </requires>
      <exception cref="T:System.ArgumentException">!( target.ReturnType == typeof( void ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateActionInvoker(System.Reflection.MethodInfo,System.Type)">
      <summary>
            	Create <see cref="T:System.Action`2" /> as invoker with specified host type nor skipping visibility.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" /> which does not have return value.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this.</param>
      <returns>
        <see cref="T:System.Action`2" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.ArgumentException"> target.ReturnType == typeof( void ) </requires>
      <exception cref="T:System.ArgumentException">!( target.ReturnType == typeof( void ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateActionInvoker(System.Reflection.MethodInfo,System.Type,System.Boolean)">
      <summary>
            	Create <see cref="T:System.Action`2" /> as invoker with specified host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" /> which does not have return value.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this.</param>
      <param name="skipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <returns>
        <see cref="T:System.Action`2" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.ArgumentException"> target.ReturnType == typeof( void ) </requires>
      <exception cref="T:System.ArgumentException">!( target.ReturnType == typeof( void ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateFuncInvoker(System.Reflection.MethodBase)">
      <summary>
            	Create <see cref="T:System.Func`3" /> as invoker without host type nor skipping visibility.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodBase" /> which is method having return value or instance constructor.</param>
      <returns>
        <see cref="T:System.Func`3" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method or constructor, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires description="!target.IsTypeInitializer" exception="T:System.NotSupportedException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" )</requires>
      <exception cref="T:System.NotSupportedException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ))</exception>
      <requires exception="T:System.ArgumentException"> target.IsPublic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsPublic )</exception>
      <requires exception="T:System.ArgumentException"> target as MethodInfo == null || ( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle </requires>
      <exception cref="T:System.ArgumentException"> target as MethodInfo != null &amp;&amp; !(( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateFuncInvoker(System.Reflection.MethodBase,System.Boolean)">
      <summary>
            	Create <see cref="T:System.Func`3" /> as invoker without host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodBase" /> which is method having return value or instance constructor.</param>
      <param name="restrictedSkipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <returns>
        <see cref="T:System.Func`3" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method or constructor, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires description="!target.IsTypeInitializer" exception="T:System.NotSupportedException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" )</requires>
      <exception cref="T:System.NotSupportedException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ))</exception>
      <requires exception="T:System.ArgumentException"> target.IsPublic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsPublic )</exception>
      <requires exception="T:System.ArgumentException"> target as MethodInfo == null || ( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle </requires>
      <exception cref="T:System.ArgumentException"> target as MethodInfo != null &amp;&amp; !(( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateFuncInvoker(System.Reflection.MethodBase,System.Type)">
      <summary>
            	Create <see cref="T:System.Func`3" /> as invoker with specified host type nor skipping visibility.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodBase" /> which is method having return value or instance constructor.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this.</param>
      <returns>
        <see cref="T:System.Func`3" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method or constructor, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.NotSupportedException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) </requires>
      <exception cref="T:System.NotSupportedException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) )</exception>
      <requires exception="T:System.ArgumentException"> target as MethodInfo == null || ( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle </requires>
      <exception cref="T:System.ArgumentException"> target as MethodInfo != null &amp;&amp; !(( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.CreateFuncInvoker(System.Reflection.MethodBase,System.Type,System.Boolean)">
      <summary>
            	Create <see cref="T:System.Func`3" /> as invoker with specified host type nor skipping visibility.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodBase" /> which is method having return value or instance constructor.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this.</param>
      <param name="skipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <returns>
        <see cref="T:System.Func`3" /> as invoker without host type.
            	Its 1st argument is instance as instance method target (for static method or constructor, this should be null).
            	2nd argument is arguments for the target.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.NotSupportedException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) </requires>
      <exception cref="T:System.NotSupportedException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) )</exception>
      <requires exception="T:System.ArgumentException"> target as MethodInfo == null || ( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle </requires>
      <exception cref="T:System.ArgumentException"> target as MethodInfo != null &amp;&amp; !(( target as MethodInfo ).ReturnType != typeof( void ).TypeHandle )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.Invoke(System.Reflection.MethodInfo,System.Object,System.Object[])">
      <summary>
            	Invoke target instance method without host type nor skipping visiblity.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="instance">Instance as instance method target (for static method or constructor, this should be null).</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> !target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( !target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> instance != null </requires>
      <exception cref="T:System.ArgumentNullException"> instance == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.Invoke(System.Reflection.MethodInfo,System.Boolean,System.Object,System.Object[])">
      <summary>
            	Invoke target instance method without host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="restrictedSkipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <param name="instance">Instance as instance method target (for static method or constructor, this should be null).</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> !target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( !target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> instance != null </requires>
      <exception cref="T:System.ArgumentNullException"> instance == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.Invoke(System.Reflection.MethodInfo,System.Type,System.Object,System.Object[])">
      <summary>
            	Invoke target instance method with specified host type nor skipping visiblity.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this. Normally, type of <paramref name="instance" />.</param>
      <param name="instance">Instance as instance method target (for static method or constructor, this should be null).</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> !target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( !target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.ArgumentNullException"> instance != null </requires>
      <exception cref="T:System.ArgumentNullException"> instance == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.Invoke(System.Reflection.MethodInfo,System.Type,System.Boolean,System.Object,System.Object[])">
      <summary>
            	Invoke target instance method with specified host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this. Normally, type of <paramref name="instance" />.</param>
      <param name="skipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <param name="instance">Instance as instance method target (for static method or constructor, this should be null).</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> !target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( !target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.ArgumentNullException"> instance != null </requires>
      <exception cref="T:System.ArgumentNullException"> instance == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeStatic(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            	Invoke target static method without host type nor skipping visiblity.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsStatic )</exception>
      <requires exception="T:System.ArgumentException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) </requires>
      <exception cref="T:System.ArgumentException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeStatic(System.Reflection.MethodInfo,System.Boolean,System.Object[])">
      <summary>
            	Invoke target static method without host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="restrictedSkipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsStatic )</exception>
      <requires exception="T:System.ArgumentException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) </requires>
      <exception cref="T:System.ArgumentException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeStatic(System.Reflection.MethodInfo,System.Type,System.Object[])">
      <summary>
            	Invoke target static method with specified host type nor skipping visiblity.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this. Normally, declaring type of <paramref name="target" />.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.NotSupportedException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) </requires>
      <exception cref="T:System.NotSupportedException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeStatic(System.Reflection.MethodInfo,System.Type,System.Boolean,System.Object[])">
      <summary>
            	Invoke target static method with specified host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this. Normally, declaring type of <paramref name="target" />.</param>
      <param name="skipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	Return value of invoked target.
            	If return type of <paramref name="target" /> is void, then null.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.ArgumentException"> target.IsStatic </requires>
      <exception cref="T:System.ArgumentException">!( target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
      <requires exception="T:System.NotSupportedException"> !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) </requires>
      <exception cref="T:System.NotSupportedException">!( !( target.IsSpecialName &amp;&amp; target.Name == ".cctor" ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeConstructor(System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            	Invoke target constructor without host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.ConstructorInfo" />.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	New instance created by <paramref name="target" />.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeConstructor(System.Reflection.ConstructorInfo,System.Boolean,System.Object[])">
      <summary>
            	Invoke target constructor without host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.ConstructorInfo" />.</param>
      <param name="restrictedSkipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	New instance created by <paramref name="target" />.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeConstructor(System.Reflection.ConstructorInfo,System.Type,System.Object[])">
      <summary>
            	Invoke target static method with specified host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.ConstructorInfo" />.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this. Normally, declaring type of <paramref name="target" />.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	New instance created by <paramref name="target" />.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.NotSupportedException"> !target.IsStatic </requires>
      <exception cref="T:System.NotSupportedException">!( !target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.Invoker.InvokeConstructor(System.Reflection.ConstructorInfo,System.Type,System.Boolean,System.Object[])">
      <summary>
            	Invoke target static method with specified host type.
            </summary>
      <param name="target">Target <see cref="T:System.Reflection.ConstructorInfo" />.</param>
      <param name="hostType">Host type of generated shim code. <paramref name="target" /> can access non-public member of this. Normally, declaring type of <paramref name="target" />.</param>
      <param name="skipVisibility">To skip visibility check specify <c>true</c>; otherwise <c>false</c>.</param>
      <param name="arguments">Arguments for the <paramref name="target" />.</param>
      <returns>
            	New instance created by <paramref name="target" />.
            </returns>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
      <requires exception="T:System.NotSupportedException"> !target.IsStatic </requires>
      <exception cref="T:System.NotSupportedException">!( !target.IsStatic )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
    </member>
    <member name="T:NLiblet.Reflection.ReflectionExtensions">
      <summary>
            	Defines utility extension method for reflection API.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.ReflectionExtensions.IsAssignableTo(System.Type,System.Type)">
      <summary>
            	Determines whether specified <see cref="T:System.Type" /> can be assigned to source <see cref="T:System.Type" />.
            </summary>
      <param name="source">The source type.</param>
      <param name="target">The type to compare with the source type.</param>
      <returns>
        <c>true</c> if <paramref name="source" /> and <paramref name="target" /> represent the same type, 
              or if <paramref name="target" /> is in the inheritance hierarchy of <paramref name="source" />, 
              or if <paramref name="target" /> is an interface that <paramref name="source" /> implements, 
              or if <paramref name="source" /> is a generic type parameter and <paramref name="target" /> represents one of the constraints of <paramref name="source" />. 
              <c>false</c> if none of these conditions are <c>true</c>, or if <paramref name="target" /> is <c>false</c>. 
            </returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.ReflectionExtensions.Equals(System.Type,System.Type)">
      <summary>
            	Determines whether the specified same type other <see cref="T:System.Type" /> is equal to the instance.
            </summary>
      <param name="source">The <see cref="T:System.Type" /> to compare with <paramref name="other" /> instance.</param>
      <param name="other">The <see cref="T:System.Type" /> to compare with <paramref name="source" /> instance.</param>
      <returns>
        <c>true</c> if <paramref name="other" /> is equal to <paramref name="source" /> instance; otherwise, <c>false</c>.
            </returns>
      <remarks>
            	This method compares <see cref="P:System.Type.TypeHandle" /> property.
            </remarks>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="T:NLiblet.Reflection.TracingILGenerator">
      <summary>
        <see cref="T:System.Reflection.Emit.ILGenerator" /> like IL stream builder with tracing.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.#ctor(System.Reflection.Emit.MethodBuilder,System.IO.TextWriter)">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Reflection.TracingILGenerator" /> class.
            </summary>
      <param name="methodBuilder">The method builder.</param>
      <param name="traceWriter">The trace writer.</param>
      <requires exception="T:System.ArgumentNullException"> methodBuilder != null </requires>
      <exception cref="T:System.ArgumentNullException"> methodBuilder == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.#ctor(System.Reflection.Emit.DynamicMethod,System.IO.TextWriter)">
      <summary>
            Initializes a new instance of the <see cref="T:NLiblet.Reflection.TracingILGenerator" /> class.
            </summary>
      <param name="dynamicMethod">The dynamic method.</param>
      <param name="traceWriter">The trace writer.</param>
      <requires exception="T:System.ArgumentNullException"> dynamicMethod != null </requires>
      <exception cref="T:System.ArgumentNullException"> dynamicMethod == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitRet">
      <summary>
            	Emit 'ret' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.DeclareLocal(System.Type)">
      <summary>
            	Declare local without pinning and name for debugging.
            </summary>
      <param name="localType">
        <see cref="T:System.Type" /> of local variable.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.LocalBuilder" /> to refer declared local variable.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> localType != null </requires>
      <exception cref="T:System.ArgumentNullException"> localType == null </exception>
      <ensures> Contract.Result&lt;LocalBuilder&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.DeclareLocal(System.Type,System.Boolean)">
      <summary>
            	Declare local without name for debugging.
            </summary>
      <param name="localType">
        <see cref="T:System.Type" /> of local variable.</param>
      <param name="pinned">If <c>true</c>, the local variable will be pinned.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.LocalBuilder" /> to refer declared local variable.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> localType != null </requires>
      <exception cref="T:System.ArgumentNullException"> localType == null </exception>
      <ensures> Contract.Result&lt;LocalBuilder&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.DeclareLocal(System.Type,System.String)">
      <summary>
            	Declare local with name for debugging and without pinning.
            	Note that this method is not enabled for dynamic method.
            </summary>
      <param name="localType">
        <see cref="T:System.Type" /> of local variable.</param>
      <param name="name">Name of the local variable.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.LocalBuilder" /> to refer declared local variable.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> localType != null </requires>
      <exception cref="T:System.ArgumentNullException"> localType == null </exception>
      <requires exception="T:System.ArgumentNullException"> name != null </requires>
      <exception cref="T:System.ArgumentNullException"> name == null </exception>
      <requires exception="T:System.ArgumentException"> ILAssemblyLanguage.IsValidId( name ) </requires>
      <exception cref="T:System.ArgumentException">!( ILAssemblyLanguage.IsValidId( name ) )</exception>
      <ensures> Contract.Result&lt;LocalBuilder&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.DeclareLocal(System.Type,System.String,System.Boolean)">
      <summary>
            	Declare local with name for debugging.
            	Note that this method is not enabled for dynamic method.
            </summary>
      <param name="localType">
        <see cref="T:System.Type" /> of local variable.</param>
      <param name="name">Name of the local variable.</param>
      <param name="pinned">If <c>true</c>, the local variable will be pinned.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.LocalBuilder" /> to refer declared local variable.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> localType != null </requires>
      <exception cref="T:System.ArgumentNullException"> localType == null </exception>
      <requires exception="T:System.ArgumentNullException"> name != null </requires>
      <exception cref="T:System.ArgumentNullException"> name == null </exception>
      <requires exception="T:System.ArgumentException"> ILAssemblyLanguage.IsValidId( name ) </requires>
      <exception cref="T:System.ArgumentException">!( ILAssemblyLanguage.IsValidId( name ) )</exception>
      <ensures> Contract.Result&lt;LocalBuilder&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitExceptionBlock(System.Action{NLiblet.Reflection.TracingILGenerator,System.Reflection.Emit.Label},System.Tuple{System.Type,System.Action{NLiblet.Reflection.TracingILGenerator,System.Reflection.Emit.Label,System.Type}},System.Tuple{System.Type,System.Action{NLiblet.Reflection.TracingILGenerator,System.Reflection.Emit.Label,System.Type}}[])">
      <summary>
            	Emit exception block with catch blocks.
            </summary>
      <param name="tryBlockEmitter">
        <see cref="T:System.Action`2" /> which emits exception block (try in C#) body.
            	A 1st argument is this <see cref="T:NLiblet.Reflection.TracingILGenerator" />,
            	and a 2nd argument is <see cref="T:System.Reflection.Emit.Label" /> will to be end of emitting exception block.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
      <param name="firstCatchBlock">
        <see cref="T:System.Tuple`2" /> for catch block body emittion.
            	A 1st item of the tuple is <see cref="T:System.Type" /> which indicates catching exception type.
            	A 2nd item of the tuple is <see cref="T:System.Action`2" /> which emits catch block body.
            	A 1st argument of the delegate is this <see cref="T:NLiblet.Reflection.TracingILGenerator" />,
            	a 2nd argument of the delegate is <see cref="T:System.Reflection.Emit.Label" /> will to be end of emitting exception block,
            	and 3rd argument of the delegate is the 1st item of the tuple.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
      <param name="remainingCatchBlockEmitters">
        <see cref="T:System.Tuple`2" /> for catch block body emittion.
            	A 1st item of the tuple is <see cref="T:System.Type" /> which indicates catching exception type.
            	A 2nd item of the tuple is <see cref="T:System.Action`2" /> which emits catch block body.
            	A 1st argument of the delegate is this <see cref="T:NLiblet.Reflection.TracingILGenerator" />,
            	a 2nd argument of the delegate is <see cref="T:System.Reflection.Emit.Label" /> will to be end of emitting exception block,
            	and 3rd argument of the delegate is the 1st item of the tuple.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> tryBlockEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> tryBlockEmitter == null </exception>
      <requires exception="T:System.ArgumentNullException"> firstCatchBlock != null </requires>
      <exception cref="T:System.ArgumentNullException"> firstCatchBlock == null </exception>
      <requires exception="T:System.ArgumentException"> firstCatchBlock.Item1 != null &amp;&amp; firstCatchBlock.Item2 != null </requires>
      <exception cref="T:System.ArgumentException"> firstCatchBlock.Item1 == null || firstCatchBlock.Item2 == null </exception>
      <requires exception="T:System.ArgumentNullException"> remainingCatchBlockEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> remainingCatchBlockEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( remainingCatchBlockEmitters, item =&gt; item != null &amp;&amp; item.Item1 != null &amp;&amp; item.Item2 != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( remainingCatchBlockEmitters, item =&gt; item != null &amp;&amp; item.Item1 != null &amp;&amp; item.Item2 != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitExceptionBlock(System.Action{NLiblet.Reflection.TracingILGenerator,System.Reflection.Emit.Label},System.Action{NLiblet.Reflection.TracingILGenerator,System.Reflection.Emit.Label},System.Tuple{System.Type,System.Action{NLiblet.Reflection.TracingILGenerator,System.Reflection.Emit.Label,System.Type}}[])">
      <summary>
            	Emit exception block with catch blocks and a finally block.
            </summary>
      <param name="tryBlockEmitter">
        <see cref="T:System.Action`2" /> which emits exception block (try in C#) body.
            	A 1st argument is this <see cref="T:NLiblet.Reflection.TracingILGenerator" />,
            	and a 2nd argument is <see cref="T:System.Reflection.Emit.Label" /> will to be end of emitting exception block.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
      <param name="finallyBlockEmitter">
        <see cref="T:System.Action`2" /> which emits finally block  body.
            	A 1st argument is this <see cref="T:NLiblet.Reflection.TracingILGenerator" />,
            	and a 2nd argument is <see cref="T:System.Reflection.Emit.Label" /> will to be end of emitting exception block.
            	The delegate do not have to emit endfinally instrauction at tail of the body.
            </param>
      <param name="catchBlockEmitters">
        <see cref="T:System.Tuple`2" /> for catch block body emittion.
            	A 1st item of the tuple is <see cref="T:System.Type" /> which indicates catching exception type.
            	A 2nd item of the tuple is <see cref="T:System.Action`2" /> which emits catch block body.
            	A 1st argument of the delegate is this <see cref="T:NLiblet.Reflection.TracingILGenerator" />,
            	a 2nd argument of the delegate is <see cref="T:System.Reflection.Emit.Label" /> will to be end of emitting exception block,
            	and 3rd argument of the delegate is the 1st item of the tuple.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> tryBlockEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> tryBlockEmitter == null </exception>
      <requires exception="T:System.ArgumentNullException"> finallyBlockEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> finallyBlockEmitter == null </exception>
      <requires exception="T:System.ArgumentNullException"> catchBlockEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> catchBlockEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( catchBlockEmitters, item =&gt; item != null &amp;&amp; item.Item1 != null &amp;&amp; item.Item2 != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( catchBlockEmitters, item =&gt; item != null &amp;&amp; item.Item1 != null &amp;&amp; item.Item2 != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.BeginExceptionBlock">
      <summary>
            	Begin exception block (try in C#) here.
            	Note that you do not have to emit leave or laeve.s instrauction at tail of the body.
            </summary>
      <returns>
        <see cref="T:System.Reflection.Emit.Label" /> will to be end of begun exception block.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.BeginCatchBlock(System.Type)">
      <summary>
            	Begin catch block with specified exception.
            	Note that you do not have to emit leave or laeve.s instrauction at tail of the body.
            </summary>
      <param name="exceptionType">
        <see cref="T:System.Type" /> for catch.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> exceptionType != null </requires>
      <exception cref="T:System.ArgumentNullException"> exceptionType == null </exception>
      <requires exception="T:System.InvalidOperationException"> this.IsInExceptionBlock </requires>
      <exception cref="T:System.InvalidOperationException">!( this.IsInExceptionBlock )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.BeginExceptFilterBlock">
      <summary>
            	Begin filter block.
            	Note that you do not have to emit leave or laeve.s instrauction at tail of the body.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.InvalidOperationException"> this.IsInExceptionBlock </requires>
      <exception cref="T:System.InvalidOperationException">!( this.IsInExceptionBlock )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.BeginFaultBlock">
      <summary>
            	Begin fault block.
            	Note that you do not have to emit endfinally instrauction at tail of the body.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.InvalidOperationException"> this.IsInExceptionBlock </requires>
      <exception cref="T:System.InvalidOperationException">!( this.IsInExceptionBlock )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.BeginFinallyBlock">
      <summary>
            	Begin finally block.
            	Note that you do not have to emit endfinally instrauction at tail of the body.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.InvalidOperationException"> this.IsInExceptionBlock </requires>
      <exception cref="T:System.InvalidOperationException">!( this.IsInExceptionBlock )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EndExceptionBlock">
      <summary>
            	End current exception block and its last clause.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.InvalidOperationException"> this.IsInExceptionBlock </requires>
      <exception cref="T:System.InvalidOperationException">!( this.IsInExceptionBlock )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.DefineLabel">
      <summary>
            	Define new <see cref="T:System.Reflection.Emit.Label" /> without name for tracing.
            </summary>
      <returns>
        <see cref="T:System.Reflection.Emit.Label" /> which will be target of branch instructions.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.DefineLabel(System.String)">
      <summary>
            	Define new <see cref="T:System.Reflection.Emit.Label" /> with name for tracing.
            </summary>
      <param name="name">Name of label. Note that debugging information will not have this name.</param>
      <returns>
        <see cref="T:System.Reflection.Emit.Label" /> which will be target of branch instructions.</returns>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> name != null </requires>
      <exception cref="T:System.ArgumentNullException"> name == null </exception>
      <requires exception="T:System.ArgumentException"> ILAssemblyLanguage.IsValidId( name ) </requires>
      <exception cref="T:System.ArgumentException">!( ILAssemblyLanguage.IsValidId( name ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.MarkLabel(System.Reflection.Emit.Label)">
      <summary>
            	Mark current position using specifieid <see cref="T:System.Reflection.Emit.Label" />.
            </summary>
      <param name="label">
        <see cref="T:System.Reflection.Emit.Label" />.</param>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCalli(System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
      <summary>
            	Emit 'calli' instruction for indirect unmanaged function call.
            </summary>
      <param name="unmanagedCallingConvention">
        <see cref="T:System.Runtime.InteropServices.CallingConvention" /> of unmanaged function.</param>
      <param name="returnType">Return <see cref="T:System.Type" /> of the function.</param>
      <param name="parameterTypes">Parameter <see cref="T:System.Type" />s of the function.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> returnType != null </requires>
      <exception cref="T:System.ArgumentNullException"> returnType == null </exception>
      <requires exception="T:System.ArgumentNullException"> parameterTypes != null </requires>
      <exception cref="T:System.ArgumentNullException"> parameterTypes == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( parameterTypes, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( parameterTypes, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCalli(System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
      <summary>
            	Emit 'calli' instruction for indirect managed method call.
            </summary>
      <param name="managedCallingConventions">
        <see cref="T:System.Reflection.CallingConventions" /> of managed method.</param>
      <param name="returnType">Return <see cref="T:System.Type" /> of the method.</param>
      <param name="requiredParameterTypes">Required parameter <see cref="T:System.Type" />s of the method.</param>
      <param name="optionalParameterTypes">Optional varargs parameter <see cref="T:System.Type" />s of the method.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> returnType != null </requires>
      <exception cref="T:System.ArgumentNullException"> returnType == null </exception>
      <requires exception="T:System.ArgumentNullException"> requiredParameterTypes != null </requires>
      <exception cref="T:System.ArgumentNullException"> requiredParameterTypes == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( requiredParameterTypes, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( requiredParameterTypes, item =&gt; item != null ) )</exception>
      <requires exception="T:System.ArgumentNullException"> optionalParameterTypes != null </requires>
      <exception cref="T:System.ArgumentNullException"> optionalParameterTypes == null </exception>
      <requires exception="T:System.InvalidOperationException">
				optionalParameterTypes == null
				|| optionalParameterTypes.Length == 0
				|| ( managedCallingConventions &amp; CallingConventions.VarArgs ) == CallingConventions.VarArgs</requires>
      <exception cref="T:System.InvalidOperationException">
				optionalParameterTypes != null &amp;&amp; optionalParameterTypes.Length != 0 &amp;&amp; !(( managedCallingConventions &amp; CallingConventions.VarArgs ) == CallingConventions.VarArgs)</exception>
      <requires exception="T:System.ArgumentException"> optionalParameterTypes == null || Contract.ForAll( optionalParameterTypes, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException"> optionalParameterTypes != null &amp;&amp; !(Contract.ForAll( optionalParameterTypes, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConstrainedCallvirt(System.Type,System.Reflection.MethodInfo)">
      <summary>
            	Emit constrained 'callvirt' instruction.
            </summary>
      <param name="constrainedTo">
        <see cref="T:System.Type" /> to be constrained to.</param>
      <param name="target">Target <see cref="T:System.Reflection.MethodInfo" /> which must be virtual method.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> constrainedTo != null </requires>
      <exception cref="T:System.ArgumentNullException"> constrainedTo == null </exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitReadOnlyLdelema(System.Type)">
      <summary>
            	Emit readonly 'ldelema' instruction.
            </summary>
      <param name="elementType">
        <see cref="T:System.Type" /> of array element.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> elementType != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementType == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitTailCall(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'call' instruction with specified arguments as tail call.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> as target.</param>
      <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitTailCallVirt(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'callvirt' instruction with specified arguments as tail call.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> as target.</param>
      <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitTailCalli(System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
      <summary>
            	Emit 'calli' instruction for indirect unmanaged function call as tail call.
            </summary>
      <param name="unmanagedCallingConvention">
        <see cref="T:System.Runtime.InteropServices.CallingConvention" /> of unmanaged function.</param>
      <param name="returnType">Return <see cref="T:System.Type" /> of the function.</param>
      <param name="parameterTypes">Parameter <see cref="T:System.Type" />s of the function.</param>
      <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> returnType != null </requires>
      <exception cref="T:System.ArgumentNullException"> returnType == null </exception>
      <requires exception="T:System.ArgumentNullException"> parameterTypes != null </requires>
      <exception cref="T:System.ArgumentNullException"> parameterTypes == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( parameterTypes, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( parameterTypes, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitTailCalli(System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
      <summary>
            	Emit 'calli' instruction for indirect managed method call as tail call.
            </summary>
      <param name="managedCallingConventions">
        <see cref="T:System.Reflection.CallingConventions" /> of managed method.</param>
      <param name="returnType">Return <see cref="T:System.Type" /> of the method.</param>
      <param name="requiredParameterTypes">Required parameter <see cref="T:System.Type" />s of the method.</param>
      <param name="optionalParameterTypes">Optional varargs parameter <see cref="T:System.Type" />s of the method.</param>
      <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> returnType != null </requires>
      <exception cref="T:System.ArgumentNullException"> returnType == null </exception>
      <requires exception="T:System.ArgumentNullException"> requiredParameterTypes != null </requires>
      <exception cref="T:System.ArgumentNullException"> requiredParameterTypes == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( requiredParameterTypes, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( requiredParameterTypes, item =&gt; item != null ) )</exception>
      <requires exception="T:System.ArgumentNullException"> optionalParameterTypes != null </requires>
      <exception cref="T:System.ArgumentNullException"> optionalParameterTypes == null </exception>
      <requires exception="T:System.InvalidOperationException">
				optionalParameterTypes == null
				|| optionalParameterTypes.Length == 0
				|| ( managedCallingConventions &amp; CallingConventions.VarArgs ) == CallingConventions.VarArgs</requires>
      <exception cref="T:System.InvalidOperationException">
				optionalParameterTypes != null &amp;&amp; optionalParameterTypes.Length != 0 &amp;&amp; !(( managedCallingConventions &amp; CallingConventions.VarArgs ) == CallingConventions.VarArgs)</exception>
      <requires exception="T:System.ArgumentException"> optionalParameterTypes == null || Contract.ForAll( optionalParameterTypes, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException"> optionalParameterTypes != null &amp;&amp; !(Contract.ForAll( optionalParameterTypes, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitUnaligned(System.Byte)">
      <summary>
            	Emit 'unaligned.' prefix.
            </summary>
      <param name="alignment">Alignment.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWrite(System.String)">
      <summary>
            	Write trace message.
            </summary>
      <param name="value">The string.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWrite(System.String,System.Object)">
      <summary>
            	Write trace message.
            </summary>
      <param name="format">The format string.</param>
      <param name="arg0">Format argument.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWrite(System.String,System.Object[])">
      <summary>
            	Write trace message.
            </summary>
      <param name="format">The format string.</param>
      <param name="args">Format arguments.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWriteLine">
      <summary>
            	Write trace line break.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWriteLine(System.String)">
      <summary>
            	Write trace message followed by line break.
            </summary>
      <param name="value">The string.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWriteLine(System.String,System.Object)">
      <summary>
            	Write trace message followed by line break.
            </summary>
      <param name="format">The format string.</param>
      <param name="arg0">Format argument.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.TraceWriteLine(System.String,System.Object[])">
      <summary>
            	Write trace message followed by line break.
            </summary>
      <param name="format">The format string.</param>
      <param name="args">Format arguments.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNop">
      <summary>
            	Emit 'nop' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBreak">
      <summary>
            	Emit 'break' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarg_0">
      <summary>
            	Emit 'ldarg.0' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarg_1">
      <summary>
            	Emit 'ldarg.1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarg_2">
      <summary>
            	Emit 'ldarg.2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarg_3">
      <summary>
            	Emit 'ldarg.3' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloc_0">
      <summary>
            	Emit 'ldloc.0' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloc_1">
      <summary>
            	Emit 'ldloc.1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloc_2">
      <summary>
            	Emit 'ldloc.2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloc_3">
      <summary>
            	Emit 'ldloc.3' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStloc_0">
      <summary>
            	Emit 'stloc.0' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStloc_1">
      <summary>
            	Emit 'stloc.1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStloc_2">
      <summary>
            	Emit 'stloc.2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStloc_3">
      <summary>
            	Emit 'stloc.3' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarg_S(System.Byte)">
      <summary>
            	Emit 'ldarg.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarga_S(System.Byte)">
      <summary>
            	Emit 'ldarga.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStarg_S(System.Byte)">
      <summary>
            	Emit 'starg.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloc_S(System.Byte)">
      <summary>
            	Emit 'ldloc.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloca_S(System.Byte)">
      <summary>
            	Emit 'ldloca.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStloc_S(System.Byte)">
      <summary>
            	Emit 'stloc.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdnull">
      <summary>
            	Emit 'ldnull' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_M1">
      <summary>
            	Emit 'ldc.i4.m1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_0">
      <summary>
            	Emit 'ldc.i4.0' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_1">
      <summary>
            	Emit 'ldc.i4.1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_2">
      <summary>
            	Emit 'ldc.i4.2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_3">
      <summary>
            	Emit 'ldc.i4.3' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_4">
      <summary>
            	Emit 'ldc.i4.4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_5">
      <summary>
            	Emit 'ldc.i4.5' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_6">
      <summary>
            	Emit 'ldc.i4.6' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_7">
      <summary>
            	Emit 'ldc.i4.7' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_8">
      <summary>
            	Emit 'ldc.i4.8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4_S(System.Byte)">
      <summary>
            	Emit 'ldc.i4.s' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I4(System.Int32)">
      <summary>
            	Emit 'ldc.i4' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Int32" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_I8(System.Int64)">
      <summary>
            	Emit 'ldc.i8' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Int64" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_R4(System.Byte)">
      <summary>
            	Emit 'ldc.r4' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Byte" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdc_R8(System.Double)">
      <summary>
            	Emit 'ldc.r8' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.Double" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitDup">
      <summary>
            	Emit 'dup' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitPop">
      <summary>
            	Emit 'pop' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitJmp(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'jmp' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCall(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'call' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBr_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'br.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBrfalse_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'brfalse.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBrtrue_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'brtrue.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBeq_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'beq.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBge_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bge.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBgt_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bgt.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBle_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'ble.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBlt_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'blt.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBne_Un_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bne.un.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBge_Un_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bge.un.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBgt_Un_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bgt.un.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBle_Un_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'ble.un.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBlt_Un_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'blt.un.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBr(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'br' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBrfalse(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'brfalse' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBrtrue(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'brtrue' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBeq(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'beq' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBge(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bge' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBgt(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bgt' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBle(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'ble' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBlt(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'blt' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBne_Un(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bne.un' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBge_Un(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bge.un' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBgt_Un(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'bgt.un' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBle_Un(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'ble.un' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBlt_Un(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'blt.un' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitSwitch(System.Reflection.Emit.Label[])">
      <summary>
            	Emit 'switch' instruction with specified arguments.
            </summary>
      <param name="targets">
        <see cref="T:System.Reflection.Emit.Label" />[] as targets.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> targets != null </requires>
      <exception cref="T:System.ArgumentNullException"> targets == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_I1">
      <summary>
            	Emit 'ldind.i1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_U1">
      <summary>
            	Emit 'ldind.u1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_I2">
      <summary>
            	Emit 'ldind.i2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_U2">
      <summary>
            	Emit 'ldind.u2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_I4">
      <summary>
            	Emit 'ldind.i4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_U4">
      <summary>
            	Emit 'ldind.u4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_I8">
      <summary>
            	Emit 'ldind.i8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_I">
      <summary>
            	Emit 'ldind.i' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_R4">
      <summary>
            	Emit 'ldind.r4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_R8">
      <summary>
            	Emit 'ldind.r8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdind_Ref">
      <summary>
            	Emit 'ldind.ref' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_Ref">
      <summary>
            	Emit 'stind.ref' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_I1">
      <summary>
            	Emit 'stind.i1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_I2">
      <summary>
            	Emit 'stind.i2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_I4">
      <summary>
            	Emit 'stind.i4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_I8">
      <summary>
            	Emit 'stind.i8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_R4">
      <summary>
            	Emit 'stind.r4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_R8">
      <summary>
            	Emit 'stind.r8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAdd">
      <summary>
            	Emit 'add' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitSub">
      <summary>
            	Emit 'sub' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitMul">
      <summary>
            	Emit 'mul' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitDiv">
      <summary>
            	Emit 'div' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitDiv_Un">
      <summary>
            	Emit 'div.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitRem">
      <summary>
            	Emit 'rem' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitRem_Un">
      <summary>
            	Emit 'rem.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnd">
      <summary>
            	Emit 'and' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitOr">
      <summary>
            	Emit 'or' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitXor">
      <summary>
            	Emit 'xor' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitShl">
      <summary>
            	Emit 'shl' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitShr">
      <summary>
            	Emit 'shr' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitShr_Un">
      <summary>
            	Emit 'shr.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNeg">
      <summary>
            	Emit 'neg' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNot">
      <summary>
            	Emit 'not' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_I1">
      <summary>
            	Emit 'conv.i1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_I2">
      <summary>
            	Emit 'conv.i2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_I4">
      <summary>
            	Emit 'conv.i4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_I8">
      <summary>
            	Emit 'conv.i8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_R4">
      <summary>
            	Emit 'conv.r4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_R8">
      <summary>
            	Emit 'conv.r8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_U4">
      <summary>
            	Emit 'conv.u4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_U8">
      <summary>
            	Emit 'conv.u8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCallvirt(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'callvirt' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCpobj(System.Type)">
      <summary>
            	Emit 'cpobj' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdobj(System.Type)">
      <summary>
            	Emit 'ldobj' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdstr(System.String)">
      <summary>
            	Emit 'ldstr' instruction with specified arguments.
            </summary>
      <param name="value">
        <see cref="T:System.String" /> as value.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNewobj(System.Reflection.ConstructorInfo)">
      <summary>
            	Emit 'newobj' instruction with specified arguments.
            </summary>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> as constructor.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> constructor != null </requires>
      <exception cref="T:System.ArgumentNullException"> constructor == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCastclass(System.Type)">
      <summary>
            	Emit 'castclass' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitIsinst(System.Type)">
      <summary>
            	Emit 'isinst' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_R_Un">
      <summary>
            	Emit 'conv.r.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitUnbox(System.Type)">
      <summary>
            	Emit 'unbox' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitThrow">
      <summary>
            	Emit 'throw' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdfld(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'ldfld' instruction with specified arguments.
            </summary>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> as field.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> field != null </requires>
      <exception cref="T:System.ArgumentNullException"> field == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdflda(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'ldflda' instruction with specified arguments.
            </summary>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> as field.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> field != null </requires>
      <exception cref="T:System.ArgumentNullException"> field == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStfld(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'stfld' instruction with specified arguments.
            </summary>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> as field.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> field != null </requires>
      <exception cref="T:System.ArgumentNullException"> field == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdsfld(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'ldsfld' instruction with specified arguments.
            </summary>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> as field.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> field != null </requires>
      <exception cref="T:System.ArgumentNullException"> field == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdsflda(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'ldsflda' instruction with specified arguments.
            </summary>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> as field.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> field != null </requires>
      <exception cref="T:System.ArgumentNullException"> field == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStsfld(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'stsfld' instruction with specified arguments.
            </summary>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> as field.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> field != null </requires>
      <exception cref="T:System.ArgumentNullException"> field == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStobj(System.Type)">
      <summary>
            	Emit 'stobj' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I1_Un">
      <summary>
            	Emit 'conv.ovf.i1.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I2_Un">
      <summary>
            	Emit 'conv.ovf.i2.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I4_Un">
      <summary>
            	Emit 'conv.ovf.i4.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I8_Un">
      <summary>
            	Emit 'conv.ovf.i8.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U1_Un">
      <summary>
            	Emit 'conv.ovf.u1.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U2_Un">
      <summary>
            	Emit 'conv.ovf.u2.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U4_Un">
      <summary>
            	Emit 'conv.ovf.u4.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U8_Un">
      <summary>
            	Emit 'conv.ovf.u8.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I_Un">
      <summary>
            	Emit 'conv.ovf.i.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U_Un">
      <summary>
            	Emit 'conv.ovf.u.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitBox(System.Type)">
      <summary>
            	Emit 'box' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNewarr(System.Type)">
      <summary>
            	Emit 'newarr' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdlen">
      <summary>
            	Emit 'ldlen' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelema(System.Type)">
      <summary>
            	Emit 'ldelema' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_I1">
      <summary>
            	Emit 'ldelem.i1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_U1">
      <summary>
            	Emit 'ldelem.u1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_I2">
      <summary>
            	Emit 'ldelem.i2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_U2">
      <summary>
            	Emit 'ldelem.u2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_I4">
      <summary>
            	Emit 'ldelem.i4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_U4">
      <summary>
            	Emit 'ldelem.u4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_I8">
      <summary>
            	Emit 'ldelem.i8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_I">
      <summary>
            	Emit 'ldelem.i' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_R4">
      <summary>
            	Emit 'ldelem.r4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_R8">
      <summary>
            	Emit 'ldelem.r8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem_Ref">
      <summary>
            	Emit 'ldelem.ref' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_I">
      <summary>
            	Emit 'stelem.i' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_I1">
      <summary>
            	Emit 'stelem.i1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_I2">
      <summary>
            	Emit 'stelem.i2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_I4">
      <summary>
            	Emit 'stelem.i4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_I8">
      <summary>
            	Emit 'stelem.i8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_R4">
      <summary>
            	Emit 'stelem.r4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_R8">
      <summary>
            	Emit 'stelem.r8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem_Ref">
      <summary>
            	Emit 'stelem.ref' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdelem(System.Type)">
      <summary>
            	Emit 'ldelem' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStelem(System.Type)">
      <summary>
            	Emit 'stelem' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitUnbox_Any(System.Type)">
      <summary>
            	Emit 'unbox.any' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I1">
      <summary>
            	Emit 'conv.ovf.i1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U1">
      <summary>
            	Emit 'conv.ovf.u1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I2">
      <summary>
            	Emit 'conv.ovf.i2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U2">
      <summary>
            	Emit 'conv.ovf.u2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I4">
      <summary>
            	Emit 'conv.ovf.i4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U4">
      <summary>
            	Emit 'conv.ovf.u4' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I8">
      <summary>
            	Emit 'conv.ovf.i8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U8">
      <summary>
            	Emit 'conv.ovf.u8' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitRefanyval(System.Type)">
      <summary>
            	Emit 'refanyval' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCkfinite">
      <summary>
            	Emit 'ckfinite' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitMkrefany(System.Type)">
      <summary>
            	Emit 'mkrefany' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdtoken(System.Type)">
      <summary>
            	Emit 'ldtoken' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Type" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdtoken(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'ldtoken' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdtoken(System.Reflection.FieldInfo)">
      <summary>
            	Emit 'ldtoken' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.FieldInfo" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_U2">
      <summary>
            	Emit 'conv.u2' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_U1">
      <summary>
            	Emit 'conv.u1' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_I">
      <summary>
            	Emit 'conv.i' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_I">
      <summary>
            	Emit 'conv.ovf.i' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_Ovf_U">
      <summary>
            	Emit 'conv.ovf.u' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAdd_Ovf">
      <summary>
            	Emit 'add.ovf' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAdd_Ovf_Un">
      <summary>
            	Emit 'add.ovf.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitMul_Ovf">
      <summary>
            	Emit 'mul.ovf' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitMul_Ovf_Un">
      <summary>
            	Emit 'mul.ovf.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitSub_Ovf">
      <summary>
            	Emit 'sub.ovf' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitSub_Ovf_Un">
      <summary>
            	Emit 'sub.ovf.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitEndfinally">
      <summary>
            	Emit 'endfinally' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLeave(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'leave' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLeave_S(System.Reflection.Emit.Label)">
      <summary>
            	Emit 'leave.s' instruction with specified arguments.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.Emit.Label" /> as target.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStind_I">
      <summary>
            	Emit 'stind.i' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitConv_U">
      <summary>
            	Emit 'conv.u' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitArglist">
      <summary>
            	Emit 'arglist' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCeq">
      <summary>
            	Emit 'ceq' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCgt">
      <summary>
            	Emit 'cgt' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCgt_Un">
      <summary>
            	Emit 'cgt.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitClt">
      <summary>
            	Emit 'clt' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitClt_Un">
      <summary>
            	Emit 'clt.un' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdftn(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'ldftn' instruction with specified arguments.
            </summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> as method.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> method != null </requires>
      <exception cref="T:System.ArgumentNullException"> method == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdvirtftn(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'ldvirtftn' instruction with specified arguments.
            </summary>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> as method.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> method != null </requires>
      <exception cref="T:System.ArgumentNullException"> method == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarg(System.Int32)">
      <summary>
            	Emit 'ldarg' instruction with specified arguments.
            </summary>
      <param name="index">
        <see cref="T:System.Int32" /> as index.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &lt;= index &amp;&amp; index &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &gt; index || index &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdarga(System.Int32)">
      <summary>
            	Emit 'ldarga' instruction with specified arguments.
            </summary>
      <param name="index">
        <see cref="T:System.Int32" /> as index.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &lt;= index &amp;&amp; index &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &gt; index || index &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStarg(System.Int32)">
      <summary>
            	Emit 'starg' instruction with specified arguments.
            </summary>
      <param name="index">
        <see cref="T:System.Int32" /> as index.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &lt;= index &amp;&amp; index &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &gt; index || index &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloc(System.Int32)">
      <summary>
            	Emit 'ldloc' instruction with specified arguments.
            </summary>
      <param name="index">
        <see cref="T:System.Int32" /> as index.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &lt;= index &amp;&amp; index &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &gt; index || index &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdloca(System.Int32)">
      <summary>
            	Emit 'ldloca' instruction with specified arguments.
            </summary>
      <param name="index">
        <see cref="T:System.Int32" /> as index.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &lt;= index &amp;&amp; index &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &gt; index || index &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStloc(System.Int32)">
      <summary>
            	Emit 'stloc' instruction with specified arguments.
            </summary>
      <param name="index">
        <see cref="T:System.Int32" /> as index.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &lt;= index &amp;&amp; index &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> UInt16.MinValue &gt; index || index &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLocalloc">
      <summary>
            	Emit 'localloc' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitEndfilter">
      <summary>
            	Emit 'endfilter' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitInitobj(System.Type)">
      <summary>
            	Emit 'initobj' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCpblk">
      <summary>
            	Emit 'cpblk' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitInitblk">
      <summary>
            	Emit 'initblk' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitRethrow">
      <summary>
            	Emit 'rethrow' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitSizeof(System.Type)">
      <summary>
            	Emit 'sizeof' instruction with specified arguments.
            </summary>
      <param name="type">
        <see cref="T:System.Type" /> as type.</param>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitRefanytype">
      <summary>
            	Emit 'refanytype' instruction with specified arguments.
            </summary>
      <requires exception="T:System.InvalidOperationException"> !this.IsEnded </requires>
      <exception cref="T:System.InvalidOperationException">!( !this.IsEnded )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnyCall(System.Reflection.MethodInfo)">
      <summary>
            	Emit 'call' or 'callvirt' appropriately.
            </summary>
      <param name="target">
        <see cref="T:System.Reflection.MethodInfo" /> to be called.</param>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitGetProperty(System.Reflection.PropertyInfo)">
      <summary>
            	Emit property getter invocation.
            	Pre condition is there is target instance on the top of evaluation stack when <paramref name="property" /> is instance property.
            	Post condition are that target instance will be removed from the stack for instance property, and property value will be placed on there.
            </summary>
      <param name="property">
        <see cref="T:System.Reflection.PropertyInfo" /> for target property.</param>
      <requires exception="T:System.ArgumentNullException"> property != null </requires>
      <exception cref="T:System.ArgumentNullException"> property == null </exception>
      <requires exception="T:System.ArgumentException"> property.CanRead </requires>
      <exception cref="T:System.ArgumentException">!( property.CanRead )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitCurrentCulture">
      <summary>
            	Emit <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> invocation.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitInvariantCulture">
      <summary>
            	Emit <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /> invocation.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitGetType">
      <summary>
            	Emit <see cref="M:System.Object.GetType" /> invocation.
            	Pre condition is that target instance is placed on the top of evaluation stack.
            	Post condition is that target instance will be replaced with <see cref="T:System.Type" /> of it.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStringFormat(System.Int32,System.String,System.Action{NLiblet.Reflection.TracingILGenerator}[])">
      <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> invocation with <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
      <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />.
            	Note that the type of local variable must be Object[].
            </param>
      <param name="formatLiteral">Forat string literal.</param>
      <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
      <requires exception="T:System.ArgumentNullException"> formatLiteral != null </requires>
      <exception cref="T:System.ArgumentNullException"> formatLiteral == null </exception>
      <requires exception="T:System.ArgumentException"> 0 &lt; formatLiteral.Length </requires>
      <exception cref="T:System.ArgumentException"> 0 &gt;= formatLiteral.Length </exception>
      <requires exception="T:System.ArgumentNullException"> argumentLoadingEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> argumentLoadingEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStringFormat(System.Int32,System.Type,System.String,System.Action{NLiblet.Reflection.TracingILGenerator}[])">
      <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> invocation with <see cref="P:System.Globalization.CultureInfo.CurrentCulture" />.
            </summary>
      <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />.
            	Note that the type of local variable must be Object[].
            </param>
      <param name="resource">
            	Type of resource accessor.
            </param>
      <param name="resourceKey">
            	Key of rethis. Note that this method assumes that key equals to accessor property name.
            </param>
      <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
      <requires exception="T:System.ArgumentNullException"> resource != null </requires>
      <exception cref="T:System.ArgumentNullException"> resource == null </exception>
      <requires exception="T:System.ArgumentNullException"> resourceKey != null </requires>
      <exception cref="T:System.ArgumentNullException"> resourceKey == null </exception>
      <requires exception="T:System.ArgumentException"> !String.IsNullOrWhiteSpace( resourceKey ) </requires>
      <exception cref="T:System.ArgumentException">!( !String.IsNullOrWhiteSpace( resourceKey ) )</exception>
      <requires exception="T:System.ArgumentNullException"> argumentLoadingEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> argumentLoadingEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStringFormatInvariant(System.Int32,System.String,System.Action{NLiblet.Reflection.TracingILGenerator}[])">
      <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> invocation with <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
      <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />.
            	Note that the type of local variable must be Object[].
            </param>
      <param name="formatLiteral">Forat string literal.</param>
      <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
      <requires exception="T:System.ArgumentNullException"> formatLiteral != null </requires>
      <exception cref="T:System.ArgumentNullException"> formatLiteral == null </exception>
      <requires exception="T:System.ArgumentException"> 0 &lt; formatLiteral.Length </requires>
      <exception cref="T:System.ArgumentException"> 0 &gt;= formatLiteral.Length </exception>
      <requires exception="T:System.ArgumentNullException"> argumentLoadingEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> argumentLoadingEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitStringFormatInvariant(System.Int32,System.Type,System.String,System.Action{NLiblet.Reflection.TracingILGenerator}[])">
      <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> invocation with <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
      <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />.
            	Note that the type of local variable must be Object[].
            </param>
      <param name="resource">
            	Type of resource accessor.
            </param>
      <param name="resourceKey">
            	Key of rethis. Note that this method assumes that key equals to accessor property name.
            </param>
      <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
      <requires exception="T:System.ArgumentNullException"> resource != null </requires>
      <exception cref="T:System.ArgumentNullException"> resource == null </exception>
      <requires exception="T:System.ArgumentNullException"> resourceKey != null </requires>
      <exception cref="T:System.ArgumentNullException"> resourceKey == null </exception>
      <requires exception="T:System.ArgumentException"> !String.IsNullOrWhiteSpace( resourceKey ) </requires>
      <exception cref="T:System.ArgumentException">!( !String.IsNullOrWhiteSpace( resourceKey ) )</exception>
      <requires exception="T:System.ArgumentNullException"> argumentLoadingEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> argumentLoadingEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( argumentLoadingEmitters, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLdargThis">
      <summary>
            	Emit load 'this' pointer instruction (namely 'ldarg.0').
            	Post condition is that the loaded value will be added on the evaluation stack.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnyLdarg(System.Int32)">
      <summary>
            	Emit apprpriate 'ldarg.*' instruction.
            	Post condition is that the loaded value will be added on the evaluation stack.
            </summary>
      <param name="argumentIndex">
            	Index of argument to be fetched.
            </param>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= argumentIndex &amp;&amp; argumentIndex &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; argumentIndex || argumentIndex &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnyLdloc(System.Int32)">
      <summary>
            	Emit apprpriate 'ldloc.*' instruction.
            	Post condition is that the loaded value will be added on the evaluation stack.
            </summary>
      <param name="localIndex">
            	Index of local variable to be fetched.
            </param>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= localIndex &amp;&amp; localIndex &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; localIndex || localIndex &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnyStloc(System.Int32)">
      <summary>
            	Emit array initialization code with initializer.
            	Pre condition is that the storing value is placed on the top of evaluation stack and its type is valid.
            	Post condition is that the stored value will be removed from the evaluation stack.
            </summary>
      <param name="localIndex">
            	Index of local variable which stores the array.
            </param>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= localIndex &amp;&amp; localIndex &lt;= UInt16.MaxValue </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; localIndex || localIndex &gt; UInt16.MaxValue </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNewarr(System.Type,System.Int64)">
      <summary>
            	Emit array initialization code without initializer.
            	Post condition is evaluation stack will no be modified as previous state. 
            	Note that initialized array is not placed on the top of evaluation stack.
            </summary>
      <param name="elementType">
        <see cref="T:System.Type" /> of array element. This can be generaic parameter.</param>
      <param name="length">Size of array.</param>
      <requires exception="T:System.ArgumentNullException"> elementType != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementType == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; length </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNewarr(System.Int32,System.Type,System.Action{NLiblet.Reflection.TracingILGenerator}[])">
      <summary>
            	Emit array initialization code with initializer.
            	Post condition is evaluation stack will no be modified as previous state. 
            	Note that initialized array is not placed on the top of evaluation stack.
            </summary>
      <param name="arrayLocalIndex">
            	Index of local variable which stores the array.
            </param>
      <param name="elementType">
        <see cref="T:System.Type" /> of array element. This can be generaic parameter.</param>
      <param name="elementLoadingEmitters">
            	List of delegates to emittion of storing element loading instruction. 
            	Index of this array corresponds to index of initializing array.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of stack and its type is <paramref name="elementType" /> compatible.
            </param>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= arrayLocalIndex </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; arrayLocalIndex </exception>
      <requires exception="T:System.ArgumentNullException"> elementType != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementType == null </exception>
      <requires exception="T:System.ArgumentNullException"> elementLoadingEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementLoadingEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( elementLoadingEmitters, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( elementLoadingEmitters, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitNewarr(System.Action{NLiblet.Reflection.TracingILGenerator},System.Action{NLiblet.Reflection.TracingILGenerator},System.Type,System.Action{NLiblet.Reflection.TracingILGenerator}[])">
      <summary>
            	Emit array initialization code with initializer.
            	Post condition is evaluation stack will no be modified as previous state. 
            	Note that initialized array is not placed on the top of evaluation stack.
            </summary>
      <param name="arrayLoadingEmitter">
            	Delegate to emittion of array loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one target array will be added on the top of stack and element type is <paramref name="elementType" />.
            </param>
      <param name="arrayStoringEmitter">
            	Delegate to emittion of array storing instruction. 
            	1st argument is this instance.
            	Pre condition is that the top of evaluation stack is array type and its element type is <paramref name="elementType" />.
            	Post condition is that exactly one target array will be removed from the top of stack.
            </param>
      <param name="elementType">
        <see cref="T:System.Type" /> of array element. This can be generaic parameter.</param>
      <param name="elementLoadingEmitters">
            	List of delegates to emittion of storing element loading instruction. 
            	Index of this array corresponds to index of initializing array.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of stack and its type is <paramref name="elementType" /> compatible.
            </param>
      <requires exception="T:System.ArgumentNullException"> arrayLoadingEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> arrayLoadingEmitter == null </exception>
      <requires exception="T:System.ArgumentNullException"> arrayStoringEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> arrayStoringEmitter == null </exception>
      <requires exception="T:System.ArgumentNullException"> elementType != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementType == null </exception>
      <requires exception="T:System.ArgumentNullException"> elementLoadingEmitters != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementLoadingEmitters == null </exception>
      <requires exception="T:System.ArgumentException"> Contract.ForAll( elementLoadingEmitters, item =&gt; item != null ) </requires>
      <exception cref="T:System.ArgumentException">!( Contract.ForAll( elementLoadingEmitters, item =&gt; item != null ) )</exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnyLdelem(System.Type,System.Action{NLiblet.Reflection.TracingILGenerator},System.Int64)">
      <summary>
            	Emit array element loading instructions. 
            	Post condition is that exactly one loaded element will be placed on the top of stack and its element type is <paramref name="elementType" />.
            </summary>
      <param name="elementType">
        <see cref="T:System.Type" /> of array element. This can be generaic parameter.</param>
      <param name="arrayLoadingEmitter">
            	Delegate to emittion of array loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one target array will be added on the top of stack and its element type is <paramref name="elementType" />.
            </param>
      <param name="index">Index of array element.</param>
      <requires exception="T:System.ArgumentNullException"> elementType != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementType == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentNullException"> arrayLoadingEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> arrayLoadingEmitter == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitAnyStelem(System.Type,System.Action{NLiblet.Reflection.TracingILGenerator},System.Int64,System.Action{NLiblet.Reflection.TracingILGenerator})">
      <summary>
            	Emit array element storing instructions.
            	Post condition is evaluation stack will no be modified as previous state.
            </summary>
      <param name="elementType">
        <see cref="T:System.Type" /> of array element. This can be generaic parameter.</param>
      <param name="arrayLoadingEmitter">
            	Delegate to emittion of array loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one target array will be added on the top of stack and its element type is <paramref name="elementType" />.
            </param>
      <param name="index">Index of array element.</param>
      <param name="elementLoadingEmitter">
            	Delegate to emittion of storing element loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of stack and its type is <paramref name="elementType" /> compatible.
            </param>
      <requires exception="T:System.ArgumentNullException"> elementType != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementType == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentNullException"> arrayLoadingEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> arrayLoadingEmitter == null </exception>
      <requires exception="T:System.ArgumentNullException"> elementLoadingEmitter != null </requires>
      <exception cref="T:System.ArgumentNullException"> elementLoadingEmitter == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitLiteralInteger(System.Int64)">
      <summary>
            	Emit efficient integer constant loading.
            	Post condition is that exactly one integer will be added on the top of stack.
            </summary>
      <param name="value">Integer value.</param>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitTypeOf(System.Type)">
      <summary>
            	Emit 'typeof' expression.
            	Post condition is <see cref="T:System.Type" /> instance for <paramref name="type" /> will be placed on the top of evaluation stack.
            </summary>
      <param name="type">Target <see cref="T:System.Type" />.</param>
      <requires exception="T:System.ArgumentNullException"> type != null </requires>
      <exception cref="T:System.ArgumentNullException"> type == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitThrowNewArgumentExceptionWithInnerException">
      <summary>
            	Emit 'throw new ArgumentException(String,String,Exception)' statement.
            	Pre condition is that there are exactly three entries in the evaluation stack,
            	which are string, string, and Exception instance.
            	Post condition is that the evaluation statck will be empty.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.TracingILGenerator.EmitThrowNewExceptionWithInnerException(System.Type)">
      <summary>
            	Emit 'throw new TException(String,String,Exception)' statement.
            	Pre condition is that there are exactly two entries in the evaluation stack,
            	which are string and Exception instance.
            	Post condition is that the evaluation statck will be empty.
            </summary>
      <param name="exceptionType">
        <see cref="T:System.Type" /> of initializing and throwing <see cref="T:System.Exception" />.</param>
      <requires exception="T:System.ArgumentNullException"> exceptionType != null </requires>
      <exception cref="T:System.ArgumentNullException"> exceptionType == null </exception>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.EndOfMethod">
      <summary>
            	Get <see cref="T:System.Reflection.Emit.Label" /> for end of method.
            </summary>
      <value>
        <see cref="T:System.Reflection.Emit.Label" /> for end of method.
            </value>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.EndOfCurrentExceptionBlock">
      <summary>
            	Get <see cref="T:System.Reflection.Emit.Label" /> for end of current exception blocks.
            </summary>
      <value>
        <see cref="T:System.Reflection.Emit.Label" /> for end of current exception blocks.
            	When there are no exception blocks, then null.
            </value>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.IsInExceptionBlock">
      <summary>
            	Get whether there are any exception blocks in current positon.
            </summary>
      <value>
            	If there are any exception blocks in current positon then <c>true</c>; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.IsInDynamicMethod">
      <summary>
            	Get the value whether this instance used for dynamic method.
            </summary>
      <value>If  this instance used for dynamic method then <c>true</c>; otherwise <c>false</c>.</value>
      <remarks>
            	Dynamic method does not support debugging information like local variable name.
            </remarks>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.IndentLevel">
      <summary>
            	Get level of indentation.
            </summary>
      <getter>
        <ensures> 0 &lt;= Contract.Result&lt;int&gt;() </ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.IndentCharacters">
      <summary>
            	Get or set indent characters.
            </summary>
      <value>
        <see cref="T:System.String" /> to be used to indent.
            	To reset default, specify null.
            </value>
      <getter>
        <ensures> Contract.Result&lt;string&gt;() != null </ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.LineNumber">
      <summary>
            	Get current line number.
            </summary>
      <value>Current line number.</value>
      <getter>
        <ensures> 0 &lt;= Contract.Result&lt;int&gt;() </ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Reflection.TracingILGenerator.IsEnded">
      <summary>
            	Get whether this IL stream is ended with 'ret'.
            </summary>
      <returns>
            	When this IL stream is ended with 'ret' then <c>true</c>; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:NLiblet.Reflection.MemberInfoExtensions">
      <summary>
            	Define extension method of <see cref="T:System.Reflection.MethodInfo" />.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.MemberInfoExtensions.CreateDelegate(System.Reflection.MethodBase)">
      <summary>
            	Create delegate for invoke specified public method.
            </summary>
      <param name="source">
        <see cref="T:System.Reflection.MethodInfo" />.</param>
      <returns>
            	Delegate to invoke <paramref name="source" />.
            	Its type is any of Action (when return value is void) or Func (otherwise).
            	If <paramref name="source" /> is instance method, then 1st parameter is target instance itself.
            </returns>
      <exception cref="T:System.NotSupportedException">
        <paramref name="source" /> has too many parameters.
            	Or <paramref name="source" /> is not <see cref="T:System.Reflection.MethodInfo" /> nor <see cref="T:System.Reflection.ConstructorInfo" />.
            	Or <paramref name="source" /> is type initializer (static constructor/class constructor).
            </exception>
      <remarks>
            	By invoking via delegate, you can avoid <see cref="T:System.Reflection.TargetInvocationException" /> problem.
            	You can catch the exception thrown by target or deeper methods instead of traversing <see cref="P:System.Exception.InnerException" /> of <see cref="T:System.Reflection.TargetInvocationException" />.
            	<note>
            		This method supports up to 16 parameters for static method and up to 15 parameters for instance method.
            	</note></remarks>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentException"> !source.ContainsGenericParameters </requires>
      <exception cref="T:System.ArgumentException">!( !source.ContainsGenericParameters )</exception>
    </member>
    <member name="M:NLiblet.Reflection.MemberInfoExtensions.CreateDelegate(System.Reflection.MethodBase,System.Type)">
      <summary>
            	Create delegate for invoke specified method in scope of host type.
            </summary>
      <param name="source">
        <see cref="T:System.Reflection.MethodInfo" />.</param>
      <param name="hostType">
        <see cref="T:System.Type" /> will be associated with generated shim code.</param>
      <returns>
            	Delegate to invoke <paramref name="source" />.
            	Its type is any of Action (when return value is void) or Func (otherwise).
            	If <paramref name="source" /> is instance method, then 1st parameter is target instance itself.
            </returns>
      <exception cref="T:System.NotSupportedException">
        <paramref name="source" /> has too many parameters.
            	Or <paramref name="source" /> is not <see cref="T:System.Reflection.MethodInfo" /> nor <see cref="T:System.Reflection.ConstructorInfo" />.
            	Or <paramref name="source" /> is type initializer (static constructor/class constructor).
            </exception>
      <remarks>
            	By invoking via delegate, you can avoid <see cref="T:System.Reflection.TargetInvocationException" /> problem.
            	You can catch the exception thrown by target or deeper methods instead of traversing <see cref="P:System.Exception.InnerException" /> of <see cref="T:System.Reflection.TargetInvocationException" />.
            	<note>
            		This method supports up to 16 parameters for static method and up to 15 parameters for instance method.
            	</note></remarks>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentException"> !source.ContainsGenericParameters </requires>
      <exception cref="T:System.ArgumentException">!( !source.ContainsGenericParameters )</exception>
      <requires exception="T:System.ArgumentNullException"> hostType != null </requires>
      <exception cref="T:System.ArgumentNullException"> hostType == null </exception>
    </member>
    <member name="F:NLiblet.Reflection.ShimCodeGenerator.CreateShimMethod">
      <summary>
            	CreateShim&lt;TDelegate&gt;(MethodBase,Type[],Type,Type,bool)
            </summary>
    </member>
    <member name="F:NLiblet.Reflection.ShimCodeGenerator.CreateLooseProcedureInvocationShimMethod">
      <summary>
            	CreateLooseProcedureInvocationShim(MethodBase,Type,bool)
            </summary>
    </member>
    <member name="F:NLiblet.Reflection.ShimCodeGenerator.CreateLooseFunctionInvocationShimMethod">
      <summary>
            	CreateLooseFunctionInvocationShim(MethodBase,Type,bool)
            </summary>
    </member>
    <member name="T:NLiblet.StringExtensions">
      <summary>
            	Extends <see cref="T:System.String" /> with extension methods.
            </summary>
    </member>
    <member name="M:NLiblet.StringExtensions.Slice(System.String,System.Int32,System.Int32)">
      <summary>
            	Get slice of string.
            </summary>
      <param name="source">
        <see cref="T:System.String" />.</param>
      <param name="start">Start index, inclusive.</param>
      <param name="end">End index, inclusive.</param>
      <returns>Slice of <paramref name="source" />.</returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= start </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; start </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> start &lt; source.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> start &gt;= source.Length </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= end </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; end </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> end &lt; source.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> end &gt;= source.Length </exception>
      <requires exception="T:System.InvalidOperationException"> start &lt;= end </requires>
      <exception cref="T:System.InvalidOperationException"> start &gt; end </exception>
    </member>
    <member name="M:NLiblet.StringExtensions.SubstringLoosely(System.String,System.Int32,System.Int32)">
      <summary>
            	Get substring of this <see cref="T:System.String" />.
            	When length of <see cref="T:System.String" /> is lessor than required length, this method returns shorter string.
            </summary>
      <param name="source">
        <see cref="T:System.String" />.</param>
      <param name="startIndex">
            	Index of starting substring.
            </param>
      <param name="length">
            	Requested length of substring.
            </param>
      <returns>
            	When sum of <paramref name="startIndex" /> and <paramref name="length" /> are lessor or equal to length of <paramref name="source" />, then substring of it;
            	else, returns string which starts with requested substring, and its length will be shorter than requested <paramref name="length" />.
            </returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= startIndex </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; startIndex </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> startIndex &lt; source.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> startIndex &gt;= source.Length </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; length </exception>
    </member>
    <member name="M:NLiblet.StringExtensions.SubstringLoosely(System.String,System.Int32,System.Int32,System.Nullable{System.Char})">
      <summary>
            	Get substring of this <see cref="T:System.String" />.
            	When length of <see cref="T:System.String" /> is lessor than required length, this method returns whether alternative string which is padded by padding charactor or shorter string.
            </summary>
      <param name="source">
        <see cref="T:System.String" />.</param>
      <param name="startIndex">
            	Index of starting substring.
            </param>
      <param name="length">
            	Requested length of substring.
            </param>
      <param name="padding">
            	Padding character. If this value is null, return string may be shorter than <paramref name="length" />.
            </param>
      <returns>
            	When sum of <paramref name="startIndex" /> and <paramref name="length" /> are lessor or equal to length of <paramref name="source" />, then substring of it;
            	else, if <paramref name="padding" /> is speciffied, returns string which starts with requested substring and its tail is padded with <paramref name="padding" />;
            	else, returns string which starts with requested substring, and its length will be shorter than requested <paramref name="length" />.
            </returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= startIndex </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; startIndex </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> startIndex &lt; source.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> startIndex &gt;= source.Length </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; length </exception>
    </member>
    <member name="T:NLiblet.Text.Formatters.ArraySegmentFormatter">
      <summary>
            	Non-generic entry point for array segment formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.ArraySegmentFormatter`1">
      <summary>
            	Item formatter for <see cref="T:System.ArraySegment`1" />.
            </summary>
      <typeparam name="TItem">Type of array element.</typeparam>
    </member>
    <member name="T:NLiblet.Text.Formatters.ItemFormatter`1">
      <summary>
            	Defines common base class of item formatter.
            </summary>
      <typeparam name="T" />
    </member>
    <member name="T:NLiblet.Text.Formatters.ItemFormatter">
      <summary>
            	Define non-geneneric entry points for item formatting.
            </summary>
    </member>
    <member name="M:NLiblet.Text.Formatters.ItemFormatter.Get(System.Type)">
      <summary>
            	Get appropriate formatter.
            </summary>
      <param name="itemType">Type of item.</param>
      <returns>Appropriate formatter.</returns>
      <requires> itemType != null </requires>
      <ensures> Contract.Result&lt;ItemFormatter&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Text.Formatters.ItemFormatter.Get``1">
      <summary>
            	Get appropriate formatter.
            </summary>
      <typeparam name="T">Type of item.</typeparam>
      <returns>Appropriate formatter.</returns>
      <ensures> Contract.Result&lt;IItemFormatter&lt;T&gt;&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Text.Formatters.ItemFormatter.GetCore(System.Type)">
      <summary>
            	Get appropriate formatter.
            </summary>
      <param name="itemType">Type of item.</param>
      <returns>Appropriate formatter.</returns>
    </member>
    <member name="M:NLiblet.Text.Formatters.ItemFormatter.FormatObjectTo(System.Object,NLiblet.Text.Formatters.FormattingContext)">
      <summary>
            	Format specified item using context.
            </summary>
      <param name="item">Item to be formatted.</param>
      <param name="context">Context information.</param>
    </member>
    <member name="T:NLiblet.Text.Formatters.IItemFormatter`1">
      <summary>
            	Define strongly typed interface of item formatter with contravariance.
            </summary>
      <typeparam name="T">Type of item.</typeparam>
    </member>
    <member name="T:NLiblet.Text.Formatters.BooleanFormatter">
      <summary>
            	Formatter for bool.
            	This class convert boolean to lower case string.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.BytesFormatter">
      <summary>
            	Formatter for binary stream (Byte[] etc.).
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.DateTimeFormatter">
      <summary>
            	Formatter for <see cref="T:System.DateTime" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.DictionaryFormatter">
      <summary>
            	Non-generic entrypoint for dictionary formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.DictionaryFormatter`3">
      <summary>
            	Generic formatter for dictionary/map.
            </summary>
    </member>
    <member name="T:NLiblet.Text.FormatProviders">
      <summary>
            	Defines NLiblet <see cref="T:System.IFormatProvider" />.
            </summary>
      <remarks>
        <list type="table">
          <listheader>
            <term>Format indicator</term>
            <description>Behavior</description>
          </listheader>
          <item>
            <term>a, A</term>
            <description>
              <strong>A</strong>SCII; all non-ascii charcters will be escaped with \uxxxx syntax.
              Note that alphabet characeters in hexadecimal is always uppercase.
            </description>
          </item>
          <item>
            <term>b, B</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Unicode <strong>b</strong>lock name.
              <note>
                Currently not supported.
              </note></description>
          </item>
          <item>
            <term>c, C</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Unicode <strong>c</strong>ategory
            </description>
          </item>
          <item>
            <term>d, D</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              <strong>D</strong>ecimal representation of unicode codepoint.
            </description>
          </item>
          <item>
            <term>e, E</term>
            <description>
              <strong>E</strong>scaping non printable chars with U+FFFD.
            </description>
          </item>
          <item>
            <term>g, G</term>
            <description>
              <strong>G</strong>eneral; same as 'm'.
            </description>
          </item>
          <item>
            <term>l, L</term>
            <description>
              <strong>L</strong>iteral style.
              It is similar to 's' style, but additionaly escape '"' to '\"'.
              <note>
                String entity in collections will be always escaped using this style.
              </note></description>
          </item>
          <item>
            <term>m, M</term>
            <description>
              <strong>M</strong>ulti line escaped char with \uxxxx notation.
              All control chars without line breaks, orphen surrogate, non-assinged code points will be escaped.
            </description>
          </item>
          <item>
            <term>r, R</term>
            <description>
              Raw-char without any escaping. It means that no escaping will not be performed.
            </description>
          </item>
          <item>
            <term>s, S</term>
            <description>
              <strong>S</strong>ulti line escaped char with \uxxxx notation.
              All control chars with line breaks, orphen surrogate, non-assinged code points will be escaped.
            </description>
          </item>
          <item>
            <term>U</term>
            <description>
              <para>
                <em>
                 This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Globalization.StringInfo" />, <see cref="T:System.Int32" />(indicating it will be treated as UTF-32).
                </em>
              </para>
              <para>
                For integer, consider specified <see cref="T:System.Int32" /> value as <strong>U</strong>tf-32 or <strong>U</strong>TF-16 style hexadecimal representation.
                You can specify additional format sepcifier following this like 'l', 'm', 's', 'u', 'x', etc. in this table to control format of UTF-32 value.
                For example, value '1' with format "uc" will be "Control", '0x61' with format "ub" will be "BasicLatin", and '0x1F0A1' with format "ur" will be spade ace mark.
              </para>
              <para>
                For characters, this indicator specifies hexadecimal 0 padding like "0020" instead of case of 'x' like "20".
                The alphabets in hex representation will be uppercase.
              </para>
            </description>
          </item>
          <item>
            <term>u</term>
            <description>
              <para>
                <em>
                  This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Globalization.StringInfo" />, <see cref="T:System.Int32" />(indicating it will be treated as UTF-32).
                </em>
              </para>
              <para>
                For integer, consider specified <see cref="T:System.Int32" /> value as <strong>U</strong>tf-32 or <strong>U</strong>TF-16 style hexadecimal representation.
                You can specify additional format sepcifier following this like 'l', 'm', 's', 'u', 'x', etc. in this table to control format of UTF-32 value.
                For example, value '1' with format "uc" will be "Control", '0x61' with format "ub" will be "BasicLatin", and '0x1F0A1' with format "ur" will be spade ace mark.
              </para>
              <para>
                For characters, this indicator specifies hexadecimal 0 padding like "0020" instead of case of 'x' like "20".
                The alphabets in hex representation will be lowercase.
              </para>
            </description>
          </item>
          <item>
            <term>x</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Globalization.StringInfo" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Utf-16 he<strong>x</strong>, with alphabets in hex representation will be uppercase.
            </description>
          </item>
          <item>
            <term>X</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Globalization.StringInfo" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Utf-16 he<strong>x</strong>, with alphabets in hex representation will be uppercase.
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:NLiblet.Text.FormatProviders.CurrentCulture">
      <summary>
            	Get <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Threading.Thread.CurrentCulture" />.
            </summary>
      <value>
        <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Threading.Thread.CurrentCulture" />.</value>
      <getter>
        <ensures> Contract.Result&lt;IFormatProvider&gt;() != null </ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Text.FormatProviders.InvariantCulture">
      <summary>
            	Get <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
      <value>
        <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.</value>
      <getter>
        <ensures> Contract.Result&lt;IFormatProvider&gt;() != null </ensures>
      </getter>
    </member>
    <member name="T:NLiblet.Text.Formatters.CommonCustomFormatter">
      <summary>
            	Implementing <see cref="T:System.ICustomFormatter" /> and <see cref="T:System.IFormatProvider" />.
            </summary>
    </member>
    <member name="M:NLiblet.Text.Formatters.CommonCustomFormatter.#ctor(System.IFormatProvider)">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Text.Formatters.CommonCustomFormatter" /> class.
            </summary>
      <param name="defaultFormatProvider">Format provider to format <see cref="T:System.IFormattable" /> items.</param>
      <requires> defaultFormatProvider != null </requires>
    </member>
    <member name="T:NLiblet.Text.Formatters.FormattableFormatter`1">
      <summary>
            	Formatter for non-numeric <see cref="T:System.IFormattable" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.FormattableNumericsFormatter`1">
      <summary>
            	Formatter for numerics which implements <see cref="T:System.IFormattable" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.FormattingLogics">
      <summary>
            	Define common functins to format <see cref="T:System.IFormattable" />.
            </summary>
    </member>
    <member name="F:NLiblet.Text.Formatters.FormattingLogics._nullRepresentation">
      <summary>
            	Common null representation.
            </summary>
    </member>
    <member name="F:NLiblet.Text.Formatters.FormattingLogics.CollectionItemEscapingFilter">
      <summary>
            	Common escaping filter for collection.
            </summary>
    </member>
    <member name="M:NLiblet.Text.Formatters.FormattingLogics.FormatDateTimeTo``1(``0,NLiblet.Text.Formatters.FormattingContext)">
      <summary>
            	Formats datetime equivalents and stores to the context buffer.
            </summary>
      <typeparam name="TDateTime">Type of datetime equivalent.</typeparam>
      <param name="dateTime">Formatting datetime equivalent.</param>
      <param name="context">Context information.</param>
    </member>
    <member name="M:NLiblet.Text.Formatters.FormattingLogics.FormatTimeSpanTo``1(``0,NLiblet.Text.Formatters.FormattingContext)">
      <summary>
            	Formats timespan equivalents and stores to the context buffer.
            </summary>
      <typeparam name="TTimeSpan">Type of timespan equivalent.</typeparam>
      <param name="timeSpan">Formatting timespan equivalent.</param>
      <param name="context">Context information.</param>
    </member>
    <member name="M:NLiblet.Text.Formatters.FormattingLogics.FormatSequence``1(System.Collections.Generic.IEnumerable{``0},NLiblet.Text.Formatters.FormattingContext,System.Object,System.Action{``0,NLiblet.Text.Formatters.FormattingContext,System.Object})">
      <summary>
            	Formats sequence and stores to the context buffer.
            </summary>
      <typeparam name="TElement">Type of element of sequence.</typeparam>
      <param name="sequence">Formatting sequence.</param>
      <param name="context">Context information.</param>
      <param name="state">Any object to be passed toward 3rd argument of <paramref name="elementFormatter" />. This value can be null.</param>
      <param name="elementFormatter">
            	Delegate to procedure which formats and stores each element of <paramref name="sequence" />.
            	1st argument is element of <paramref name="sequence" />.
            	2nd argument is context (same as <paramref name="context" />).
            	And 3rd argument is state object (same as <paramref name="state" />) which will be null when <paramref name="state" /> is null.
            </param>
    </member>
    <member name="M:NLiblet.Text.Formatters.FormattingLogics.FormatDictionary``1(System.Collections.Generic.IEnumerable{``0},NLiblet.Text.Formatters.FormattingContext,System.Object,System.Action{``0,NLiblet.Text.Formatters.FormattingContext,System.Object})">
      <summary>
            	Formats dictionary and stores to the context buffer.
            </summary>
      <typeparam name="TElement">Type of element of dictionary.</typeparam>
      <param name="dictionary">Formatting dictionary.</param>
      <param name="context">Context information.</param>
      <param name="state">Any object to be passed toward 3rd argument of <paramref name="elementFormatter" />. This value can be null.</param>
      <param name="elementFormatter">
            	Delegate to procedure which formats and stores each element of <paramref name="dictionary" />.
            	1st argument is element of <paramref name="dictionary" />.
            	2nd argument is context (same as <paramref name="context" />).
            	And 3rd argument is state object (same as <paramref name="state" />) which will be null when <paramref name="state" /> is null.
            </param>
    </member>
    <member name="T:NLiblet.Text.Formatters.DateTimeOffsetFormatter">
      <summary>
            	Formatter for <see cref="T:System.DateTimeOffset" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.NonGenericDictionaryFormatter">
      <summary>
            	Formatter for non-generic <see cref="T:System.Collections.IDictionary" /></summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.NonGenericSequenceFormatter">
      <summary>
            	Formatter for non-generic <see cref="T:System.Collections.IEnumerable" /></summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.NullableFormatter">
      <summary>
            	Non-generic entry point nullable formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.NullableFormatter`1">
      <summary>
            	Formatter for nullable types.
            </summary>
      <typeparam name="T">Underlying value type.</typeparam>
    </member>
    <member name="T:NLiblet.Text.Formatters.NumericsFormatter">
      <summary>
            	Defines non-generic utlities for <see cref="T:NLiblet.Text.Formatters.NumericsFormatter`1" />.
            </summary>
    </member>
    <member name="M:NLiblet.Text.Formatters.NumericsFormatter.IsNumerics(System.Type,System.Boolean@)">
      <summary>
            	Determine whether specified type is numeric.
            </summary>
      <param name="type">Type.</param>
      <param name="isFormattable">Set true if <paramref name="type" /> is formattable.</param>
      <returns>
        <c>true</c> if sepcified type is numerics.</returns>
    </member>
    <member name="T:NLiblet.Text.Formatters.NumericsFormatter`1">
      <summary>
            	Formatter for numerics.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.PolymorphicObjectFormatter">
      <summary>
            	Formatter for <see cref="T:System.Object" /> and <see cref="T:System.ValueType" /> with dispatching.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.SerializationInfoFormatter">
      <summary>
            	Formatter for <see cref="T:System.Runtime.Serialization.SerializationInfo" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.StringBuilderFormatter">
      <summary>
            	Formatter for <see cref="T:System.Text.StringBuilder" />. This class does escaping.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.StringFormatter">
      <summary>
            	Formatter for <see cref="T:System.String" /> (and its equivalents). This class does escaping.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.TimeSpanFormatter">
      <summary>
            	Formatter for <see cref="T:System.TimeSpan" /></summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.FormattableFormatter">
      <summary>
            	Non-generic entry point for formattable formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.FormattingContext">
      <summary>
            	Consolidates context information.
            </summary>
    </member>
    <member name="P:NLiblet.Text.Formatters.FormattingContext.Format">
      <summary>
            	Get format string specified to Format().
            </summary>
    </member>
    <member name="P:NLiblet.Text.Formatters.FormattingContext.FallbackProvider">
      <summary>
            	Get fallback provider which was passed on constructor. This value may be CultureInfo.
            </summary>
    </member>
    <member name="P:NLiblet.Text.Formatters.FormattingContext.Buffer">
      <summary>
            	Get buffer to append formatting result.
            </summary>
    </member>
    <member name="P:NLiblet.Text.Formatters.FormattingContext.Formatter">
      <summary>
            	Get the reference to current <see cref="T:NLiblet.Text.Formatters.CommonCustomFormatter" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.HexFormat">
      <summary>
            	Text format utilities for hexadecimal binary text representation.
            </summary>
    </member>
    <member name="M:NLiblet.Text.HexFormat.ToHexString(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            	Returns hexadecimal text representation of specified bytes.
            </summary>
      <param name="bytes">Bytes to be string. This value can be null.</param>
      <returns>
            	Hexadecimal text representation of specified <paramref name="bytes" />;
            	or empty string when <paramref name="bytes" /> is null or empty.
            </returns>
      <pure />
      <ensures> Contract.Result&lt;string&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Text.HexFormat.ToHex(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            	Returns hexadecimal text representation of specified bytes.
            </summary>
      <param name="bytes">Bytes to be string. This value can be null.</param>
      <returns>
            	Charactor sequence of hexadecimal text representation of specified <paramref name="bytes" />;
            	or empty sequence when <paramref name="bytes" /> is null or empty.
            </returns>
      <pure />
    </member>
    <member name="M:NLiblet.Text.HexFormat.GetBytesFromHex(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            	Returns binary representation of specified hexadicimal format text.
            </summary>
      <param name="hexChars">Chars to be binary. This value can be null.</param>
      <returns>
            	Byte sequence of binary representation of specified <paramref name="hexChars" />;
            	or empty sequence when <paramref name="hexChars" /> is null or empty.
            </returns>
      <exception cref="T:System.FormatException">
        <paramref name="hexChars" /> contains invalid charactor. Valid charactor is ASCII numbers or ACSII 'a', 'b', 'c', 'd', 'e', or 'f' (cases are insensitive).
            </exception>
      <pure />
    </member>
    <member name="M:NLiblet.Text.HexFormat.GetByteArrayFromHex(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            	Returns byte array for specified hexadicimal format text.
            </summary>
      <param name="hexChars">Chars to be binary. This value can be null.</param>
      <returns>
            	Byte array of binary representation of specified <paramref name="hexChars" />;
            	or empty sequence when <paramref name="hexChars" /> is null or empty.
            </returns>
      <exception cref="T:System.FormatException">
        <paramref name="hexChars" /> contains invalid charactor. Valid charactor is ASCII numbers or ACSII 'a', 'b', 'c', 'd', 'e', or 'f' (cases are insensitive).
            </exception>
      <pure />
      <ensures> Contract.Result&lt;byte[]&gt;() != null </ensures>
    </member>
    <member name="T:NLiblet.Text.LocalizedBlockName">
      <summary>
              ローカライズされた文字列などを検索するための、厳密に型指定されたリソース クラスです。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.ResourceManager">
      <summary>
              このクラスで使用されているキャッシュされた ResourceManager インスタンスを返します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.Culture">
      <summary>
              厳密に型指定されたこのリソース クラスを使用して、すべての検索リソースに対し、
              現在のスレッドの CurrentUICulture プロパティをオーバーライドします。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Aegean_Numbers">
      <summary>
              Aegean Numbers に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Alchemical_Symbols">
      <summary>
              Alchemical Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Alphabetic_Presentation_Forms">
      <summary>
              Alphabetic Presentation Forms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ancient_Greek_Musical_Notation">
      <summary>
              Ancient Greek Musical Notation に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ancient_Greek_Numbers">
      <summary>
              Ancient Greek Numbers に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ancient_Symbols">
      <summary>
              Ancient Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Arabic">
      <summary>
              Arabic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Arabic_Presentation_Forms_A">
      <summary>
              Arabic Presentation Forms-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Arabic_Presentation_Forms_B">
      <summary>
              Arabic Presentation Forms-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Arabic_Supplement">
      <summary>
              Arabic Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Armenian">
      <summary>
              Armenian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Arrows">
      <summary>
              Arrows に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Avestan">
      <summary>
              Avestan に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Balinese">
      <summary>
              Balinese に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Bamum">
      <summary>
              Bamum に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Bamum_Supplement">
      <summary>
              Bamum Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Basic_Latin">
      <summary>
              Basic Latin に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Batak">
      <summary>
              Batak に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Bengali">
      <summary>
              Bengali に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Block_Elements">
      <summary>
              Block Elements に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Bopomofo">
      <summary>
              Bopomofo に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Bopomofo_Extended">
      <summary>
              Bopomofo Extended に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Box_Drawing">
      <summary>
              Box Drawing に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Brahmi">
      <summary>
              Brahmi に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Braille_Patterns">
      <summary>
              Braille Patterns に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Buginese">
      <summary>
              Buginese に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Buhid">
      <summary>
              Buhid に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Byzantine_Musical_Symbols">
      <summary>
              Byzantine Musical Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Carian">
      <summary>
              Carian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cham">
      <summary>
              Cham に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cherokee">
      <summary>
              Cherokee に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Compatibility">
      <summary>
              CJK Compatibility に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Compatibility_Forms">
      <summary>
              CJK Compatibility Forms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Compatibility_Ideographs">
      <summary>
              CJK Compatibility Ideographs に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Compatibility_Ideographs_Supplement">
      <summary>
              CJK Compatibility Ideographs Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Radicals_Supplement">
      <summary>
              CJK Radicals Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Strokes">
      <summary>
              CJK Strokes に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Symbols_and_Punctuation">
      <summary>
              CJK Symbols and Punctuation に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Unified_Ideographs">
      <summary>
              CJK Unified Ideographs に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Unified_Ideographs_Extension_A">
      <summary>
              CJK Unified Ideographs Extension A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Unified_Ideographs_Extension_B">
      <summary>
              CJK Unified Ideographs Extension B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Unified_Ideographs_Extension_C">
      <summary>
              CJK Unified Ideographs Extension C に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_CJK_Unified_Ideographs_Extension_D">
      <summary>
              CJK Unified Ideographs Extension D に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Combining_Diacritical_Marks">
      <summary>
              Combining Diacritical Marks に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Combining_Diacritical_Marks_for_Symbols">
      <summary>
              Combining Diacritical Marks for Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Combining_Diacritical_Marks_Supplement">
      <summary>
              Combining Diacritical Marks Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Combining_Half_Marks">
      <summary>
              Combining Half Marks に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Common_Indic_Number_Forms">
      <summary>
              Common Indic Number Forms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Control_Pictures">
      <summary>
              Control Pictures に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Coptic">
      <summary>
              Coptic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Counting_Rod_Numerals">
      <summary>
              Counting Rod Numerals に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cuneiform">
      <summary>
              Cuneiform に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cuneiform_Numbers_and_Punctuation">
      <summary>
              Cuneiform Numbers and Punctuation に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Currency_Symbols">
      <summary>
              Currency Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cypriot_Syllabary">
      <summary>
              Cypriot Syllabary に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cyrillic">
      <summary>
              Cyrillic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cyrillic_Extended_A">
      <summary>
              Cyrillic Extended-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cyrillic_Extended_B">
      <summary>
              Cyrillic Extended-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Cyrillic_Supplement">
      <summary>
              Cyrillic Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Deseret">
      <summary>
              Deseret に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Devanagari">
      <summary>
              Devanagari に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Devanagari_Extended">
      <summary>
              Devanagari Extended に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Dingbats">
      <summary>
              Dingbats に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Domino_Tiles">
      <summary>
              Domino Tiles に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Egyptian_Hieroglyphs">
      <summary>
              Egyptian Hieroglyphs に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Emoticons">
      <summary>
              Emoticons に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Enclosed_Alphanumeric_Supplement">
      <summary>
              Enclosed Alphanumeric Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Enclosed_Alphanumerics">
      <summary>
              Enclosed Alphanumerics に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Enclosed_CJK_Letters_and_Months">
      <summary>
              Enclosed CJK Letters and Months に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Enclosed_Ideographic_Supplement">
      <summary>
              Enclosed Ideographic Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ethiopic">
      <summary>
              Ethiopic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ethiopic_Extended">
      <summary>
              Ethiopic Extended に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ethiopic_Extended_A">
      <summary>
              Ethiopic Extended-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ethiopic_Supplement">
      <summary>
              Ethiopic Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_General_Punctuation">
      <summary>
              General Punctuation に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Geometric_Shapes">
      <summary>
              Geometric Shapes に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Georgian">
      <summary>
              Georgian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Georgian_Supplement">
      <summary>
              Georgian Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Glagolitic">
      <summary>
              Glagolitic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Gothic">
      <summary>
              Gothic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Greek_and_Coptic">
      <summary>
              Greek and Coptic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Greek_Extended">
      <summary>
              Greek Extended に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Gujarati">
      <summary>
              Gujarati に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Gurmukhi">
      <summary>
              Gurmukhi に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Halfwidth_and_Fullwidth_Forms">
      <summary>
              Halfwidth and Fullwidth Forms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hangul_Compatibility_Jamo">
      <summary>
              Hangul Compatibility Jamo に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hangul_Jamo">
      <summary>
              Hangul Jamo に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hangul_Jamo_Extended_A">
      <summary>
              Hangul Jamo Extended-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hangul_Jamo_Extended_B">
      <summary>
              Hangul Jamo Extended-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hangul_Syllables">
      <summary>
              Hangul Syllables に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hanunoo">
      <summary>
              Hanunoo に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hebrew">
      <summary>
              Hebrew に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_High_Private_Use_Surrogates">
      <summary>
              High Private Use Surrogates に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_High_Surrogates">
      <summary>
              High Surrogates に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Hiragana">
      <summary>
              Hiragana に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ideographic_Description_Characters">
      <summary>
              Ideographic Description Characters に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Imperial_Aramaic">
      <summary>
              Imperial Aramaic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Inscriptional_Pahlavi">
      <summary>
              Inscriptional Pahlavi に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Inscriptional_Parthian">
      <summary>
              Inscriptional Parthian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_IPA_Extensions">
      <summary>
              IPA Extensions に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Javanese">
      <summary>
              Javanese に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kaithi">
      <summary>
              Kaithi に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kana_Supplement">
      <summary>
              Kana Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kanbun">
      <summary>
              Kanbun に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kangxi_Radicals">
      <summary>
              Kangxi Radicals に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kannada">
      <summary>
              Kannada に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Katakana">
      <summary>
              Katakana に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Katakana_Phonetic_Extensions">
      <summary>
              Katakana Phonetic Extensions に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kayah_Li">
      <summary>
              Kayah Li に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Kharoshthi">
      <summary>
              Kharoshthi に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Khmer">
      <summary>
              Khmer に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Khmer_Symbols">
      <summary>
              Khmer Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Lao">
      <summary>
              Lao に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Latin_1_Supplement">
      <summary>
              Latin-1 Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Latin_Extended_A">
      <summary>
              Latin Extended-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Latin_Extended_Additional">
      <summary>
              Latin Extended Additional に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Latin_Extended_B">
      <summary>
              Latin Extended-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Latin_Extended_C">
      <summary>
              Latin Extended-C に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Latin_Extended_D">
      <summary>
              Latin Extended-D に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Lepcha">
      <summary>
              Lepcha に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Letterlike_Symbols">
      <summary>
              Letterlike Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Limbu">
      <summary>
              Limbu に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Linear_B_Ideograms">
      <summary>
              Linear B Ideograms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Linear_B_Syllabary">
      <summary>
              Linear B Syllabary に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Lisu">
      <summary>
              Lisu に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Low_Surrogates">
      <summary>
              Low Surrogates に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Lycian">
      <summary>
              Lycian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Lydian">
      <summary>
              Lydian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Mahjong_Tiles">
      <summary>
              Mahjong Tiles に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Malayalam">
      <summary>
              Malayalam に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Mandaic">
      <summary>
              Mandaic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Mathematical_Alphanumeric_Symbols">
      <summary>
              Mathematical Alphanumeric Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Mathematical_Operators">
      <summary>
              Mathematical Operators に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Meetei_Mayek">
      <summary>
              Meetei Mayek に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Miscellaneous_Mathematical_Symbols_A">
      <summary>
              Miscellaneous Mathematical Symbols-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Miscellaneous_Mathematical_Symbols_B">
      <summary>
              Miscellaneous Mathematical Symbols-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Miscellaneous_Symbols">
      <summary>
              Miscellaneous Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Miscellaneous_Symbols_and_Arrows">
      <summary>
              Miscellaneous Symbols and Arrows に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Miscellaneous_Symbols_And_Pictographs">
      <summary>
              Miscellaneous Symbols And Pictographs に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Miscellaneous_Technical">
      <summary>
              Miscellaneous Technical に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Modifier_Tone_Letters">
      <summary>
              Modifier Tone Letters に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Mongolian">
      <summary>
              Mongolian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Musical_Symbols">
      <summary>
              Musical Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Myanmar">
      <summary>
              Myanmar に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Myanmar_Extended_A">
      <summary>
              Myanmar Extended-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_New_Tai_Lue">
      <summary>
              New Tai Lue に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_NKo">
      <summary>
              NKo に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Number_Forms">
      <summary>
              Number Forms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ogham">
      <summary>
              Ogham に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ol_Chiki">
      <summary>
              Ol Chiki に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Old_Italic">
      <summary>
              Old Italic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Old_Persian">
      <summary>
              Old Persian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Old_South_Arabian">
      <summary>
              Old South Arabian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Old_Turkic">
      <summary>
              Old Turkic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Optical_Character_Recognition">
      <summary>
              Optical Character Recognition に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Oriya">
      <summary>
              Oriya に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Osmanya">
      <summary>
              Osmanya に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Phags_pa">
      <summary>
              Phags-pa に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Phaistos_Disc">
      <summary>
              Phaistos Disc に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Phoenician">
      <summary>
              Phoenician に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Phonetic_Extensions">
      <summary>
              Phonetic Extensions に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Phonetic_Extensions_Supplement">
      <summary>
              Phonetic Extensions Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Playing_Cards">
      <summary>
              Playing Cards に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Private_Use_Area">
      <summary>
              Private Use Area に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Rejang">
      <summary>
              Rejang に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Rumi_Numeral_Symbols">
      <summary>
              Rumi Numeral Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Runic">
      <summary>
              Runic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Samaritan">
      <summary>
              Samaritan に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Saurashtra">
      <summary>
              Saurashtra に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Shavian">
      <summary>
              Shavian に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Sinhala">
      <summary>
              Sinhala に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Small_Form_Variants">
      <summary>
              Small Form Variants に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Spacing_Modifier_Letters">
      <summary>
              Spacing Modifier Letters に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Specials">
      <summary>
              Specials に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Sundanese">
      <summary>
              Sundanese に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Superscripts_and_Subscripts">
      <summary>
              Superscripts and Subscripts に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Supplemental_Arrows_A">
      <summary>
              Supplemental Arrows-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Supplemental_Arrows_B">
      <summary>
              Supplemental Arrows-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Supplemental_Mathematical_Operators">
      <summary>
              Supplemental Mathematical Operators に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Supplemental_Punctuation">
      <summary>
              Supplemental Punctuation に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Supplementary_Private_Use_Area_A">
      <summary>
              Supplementary Private Use Area-A に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Supplementary_Private_Use_Area_B">
      <summary>
              Supplementary Private Use Area-B に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Syloti_Nagri">
      <summary>
              Syloti Nagri に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Syriac">
      <summary>
              Syriac に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tagalog">
      <summary>
              Tagalog に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tagbanwa">
      <summary>
              Tagbanwa に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tags">
      <summary>
              Tags に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tai_Le">
      <summary>
              Tai Le に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tai_Tham">
      <summary>
              Tai Tham に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tai_Viet">
      <summary>
              Tai Viet に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tai_Xuan_Jing_Symbols">
      <summary>
              Tai Xuan Jing Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tamil">
      <summary>
              Tamil に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Telugu">
      <summary>
              Telugu に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Thaana">
      <summary>
              Thaana に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Thai">
      <summary>
              Thai に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tibetan">
      <summary>
              Tibetan に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Tifinagh">
      <summary>
              Tifinagh に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Transport_And_Map_Symbols">
      <summary>
              Transport And Map Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Ugaritic">
      <summary>
              Ugaritic に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Unified_Canadian_Aboriginal_Syllabics">
      <summary>
              Unified Canadian Aboriginal Syllabics に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Unified_Canadian_Aboriginal_Syllabics_Extended">
      <summary>
              Unified Canadian Aboriginal Syllabics Extended に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Vai">
      <summary>
              Vai に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Variation_Selectors">
      <summary>
              Variation Selectors に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Variation_Selectors_Supplement">
      <summary>
              Variation Selectors Supplement に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Vedic_Extensions">
      <summary>
              Vedic Extensions に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Vertical_Forms">
      <summary>
              Vertical Forms に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Yi_Radicals">
      <summary>
              Yi Radicals に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Yi_Syllables">
      <summary>
              Yi Syllables に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="P:NLiblet.Text.LocalizedBlockName.UnicoceBlockName_Yijing_Hexagram_Symbols">
      <summary>
              Yijing Hexagram Symbols に類似しているローカライズされた文字列を検索します。
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.ObjectFormatter">
      <summary>
        <see cref="T:NLiblet.Text.Formatters.ItemFormatter" /> specialized for <see cref="T:System.Object" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.SequenceFormatter">
      <summary>
            	Non-generic entrypoint for sequence formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.Formatters.SequenceFormatter`2">
      <summary>
            	Formatter for generic sequence.
            </summary>
    </member>
    <member name="T:NLiblet.Text.StringBuilderExtensions">
      <summary>
            	Extends <see cref="T:System.Text.StringBuilder" /> with extension methods.
            </summary>
    </member>
    <member name="M:NLiblet.Text.StringBuilderExtensions.AsEnumerable(System.Text.StringBuilder)">
      <summary>
            	Get <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerate characters of this <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="source">
        <see cref="T:System.Text.StringBuilder" />.</param>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerate characters of <paramref name="source" />.</returns>
    </member>
    <member name="M:NLiblet.Text.StringBuilderExtensions.AppendHex(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            	Append bytes as hexdecimal representation to this <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="source">
        <see cref="T:System.Text.StringBuilder" />.</param>
      <param name="bytes">Bytes. This value can be null.</param>
      <returns>
        <paramref name="source" /> to be used for chaining.</returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <ensures> Contract.Result&lt;StringBuilder&gt;() != null </ensures>
      <ensures> Object.ReferenceEquals( Contract.Result&lt;StringBuilder&gt;(), source ) </ensures>
    </member>
    <member name="M:NLiblet.Text.StringBuilderExtensions.AppendChars(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            	Append characters to this <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="source">
        <see cref="T:System.Text.StringBuilder" />.</param>
      <param name="chars">Characters. This value can be null.</param>
      <returns>
        <paramref name="source" /> to be used for chaining.</returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <ensures> Contract.Result&lt;StringBuilder&gt;() != null </ensures>
      <ensures> Object.ReferenceEquals( Contract.Result&lt;StringBuilder&gt;(), source ) </ensures>
    </member>
    <member name="T:NLiblet.Text.Formatters.TupleFormatter">
      <summary>
            	Non-generic entry point for tuple formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.UnicodeUtility">
      <summary>
            	Defines utility methods related to unicode charactors handling.
            </summary>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetUnicodeBlockName(System.Int32)">
      <summary>
            	Get unicode block name of specified UTF-32 code point.
            </summary>
      <param name="codePoint">UTF-32 code point.</param>
      <returns>Unicode block name.</returns>
      <remarks>
        <para>
            You can use unicode block name in <see cref="T:System.Text.RegularExpressions.Regex" /> class.
          </para>
        <para>
            Unicode block name is defined in Unicode Standard. You can find all block name at http://www.unicode.org/Public/UNIDATA/UnicodeData.txt.
          </para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10FFFF </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10FFFF </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetLocalizedUnicodeBlockName(System.Int32)">
      <summary>
            	Get localized unicode block name of specified UTF-32 code point with <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.
            </summary>
      <param name="codePoint">UTF-32 code point.</param>
      <returns>Localized unicode block name.</returns>
      <remarks>
        <para>
            You can use unicode block name in <see cref="T:System.Text.RegularExpressions.Regex" /> class.
          </para>
        <para>
            Unicode block name is defined in Unicode Standard. You can find all block name at http://www.unicode.org/Public/UNIDATA/UnicodeData.txt.
          </para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10FFFF </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10FFFF </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Char)">
      <summary>
            	Determine that whether specified charactor is printable.
            </summary>
      <param name="value">Char to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="value" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Char,System.Char)">
      <summary>
            	Determine that whether specified surrogate pair is printable.
            </summary>
      <param name="highSurrogate">High surrogate char.</param>
      <param name="lowSurrogate">Low surrogate char.</param>
      <returns>
        <c>true</c> if the codepoint represented by specified surrogate pair is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xd800 &lt;= highSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xd800 &gt; highSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> highSurrogate &lt;= 0xdbff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> highSurrogate &gt; 0xdbff </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xdc00 &lt;= lowSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xdc00 &gt; lowSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> lowSurrogate &lt;= 0xdfff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> lowSurrogate &gt; 0xdfff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.String,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.String" /> is printable.
            </summary>
      <param name="value">
        <see cref="T:System.String" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Text.StringBuilder,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.Text.StringBuilder" /> is printable.
            </summary>
      <param name="value">
        <see cref="T:System.Text.StringBuilder" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Collections.Generic.IList{System.Char},System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified charactor collection is printable.
            </summary>
      <param name="chars">
        <see cref="T:System.Collections.Generic.IList`1" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="chars" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> chars != null </requires>
      <exception cref="T:System.ArgumentNullException"> chars == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; chars.Count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= chars.Count </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Int32)">
      <summary>
            	Determine that whether specified UTF-32 code point is printable.
            </summary>
      <param name="codePoint">UTF-32 code point to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="codePoint" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10ffff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10ffff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Char)">
      <summary>
            	Determine that whether specified charactor should be escaped.
            </summary>
      <param name="value">Char to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="value" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Char,System.Char)">
      <summary>
            	Determine that whether specified surrogate pair should be escaped.
            </summary>
      <param name="highSurrogate">High surrogate char.</param>
      <param name="lowSurrogate">Low surrogate char.</param>
      <returns>
        <c>true</c> if the codepoint represented by specified surrogate pair should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xd800 &lt;= highSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xd800 &gt; highSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> highSurrogate &lt;= 0xdbff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> highSurrogate &gt; 0xdbff </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xdc00 &lt;= lowSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xdc00 &gt; lowSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> lowSurrogate &lt;= 0xdfff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> lowSurrogate &gt; 0xdfff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.String,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.String" /> should be escaped.
            </summary>
      <param name="value">
        <see cref="T:System.String" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Text.StringBuilder,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.Text.StringBuilder" /> should be escaped.
            </summary>
      <param name="value">
        <see cref="T:System.Text.StringBuilder" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Collections.Generic.IList{System.Char},System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified charactor collection should be escaped.
            </summary>
      <param name="chars">
        <see cref="T:System.Collections.Generic.IList`1" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="chars" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> chars != null </requires>
      <exception cref="T:System.ArgumentNullException"> chars == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; chars.Count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= chars.Count </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Int32)">
      <summary>
            	Determine that whether specified UTF-32 code point should be escaped.
            </summary>
      <param name="codePoint">UTF-32 code point to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="codePoint" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10ffff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10ffff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetUnicodeCategory(System.Int32)">
      <summary>
            	Get <see cref="T:System.Globalization.UnicodeCategory" /> for specified UTF-32 code point.
            </summary>
      <param name="utf32">UTF-32 code point.</param>
      <returns>
        <see cref="T:System.Globalization.UnicodeCategory" />.</returns>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= utf32 &amp;&amp; utf32 &lt;= 0x10ffff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; utf32 || utf32 &gt; 0x10ffff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetUnicodeBlockName(System.Char)">
      <summary>
            	Get unicode block name of specified UTF-16 charctor.
            </summary>
      <param name="utf16">Charactor.</param>
      <returns>Unicode block name.</returns>
      <remarks>
        <para>
            You can use unicode block name in <see cref="T:System.Text.RegularExpressions.Regex" /> class.
          </para>
        <para>
            Unicode block name is defined in Unicode Standard. You can find all block name at http://www.unicode.org/Public/UNIDATA/UnicodeData.txt.
          </para>
      </remarks>
    </member>
    <member name="T:NLiblet.WeakReference`1">
      <summary>
            Represents typed 'weak' reference.
            </summary>
      <typeparam name="T">Type of reference type to be wrapped.</typeparam>
    </member>
    <member name="M:NLiblet.WeakReference`1.#ctor(`0)">
      <summary>
            	Initializes a new instance without resurrection tracking.
            </summary>
      <param name="target">The target. This value is non-<c>null</c> reference type object.</param>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.WeakReference`1.#ctor(`0,System.Boolean)">
      <summary>
            	Initializes a new instance with specified resurrection tracking.
            </summary>
      <param name="target">The target. This value is non-<c>null</c> reference type object.</param>
      <param name="trackResurrection">If tracking resurrection then <c>true</c>; otherwise <c>false</c>.</param>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.WeakReference`1.Finalize">
      <summary>
            	Releases unmanaged resources and performs other cleanup operations before the
            	<see cref="T:NLiblet.WeakReference`1" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:NLiblet.WeakReference`1.Dispose">
      <summary>
            	Releases unmanaged resources and performs other cleanup operations before the
            	<see cref="T:NLiblet.WeakReference`1" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="P:NLiblet.WeakReference`1.TrackResurrection">
      <summary>
            	Gets a value indicating whether this reference tracking resurrection.
            </summary>
      <value>
        <c>true</c> if this reference tracking resurrection; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NLiblet.WeakReference`1.Target">
      <summary>
            	Gets the target object as strong reference.
            </summary>
      <value>
            	Wrapped target value. This value may not be <c>null</c>.
            </value>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="P:NLiblet.WeakReference`1.IsAlive" /> is <c>false</c>, thus target object has been already reclaimed by GC.
            </exception>
      <remarks>
            	It is possible target object has been reclaimed since most recent <see cref="P:NLiblet.WeakReference`1.IsAlive" /> call
            	because of the nature of multi-threaded environment.
            </remarks>
    </member>
    <member name="P:NLiblet.WeakReference`1.IsAlive">
      <summary>
            	Gets a value indicating whether <see cref="P:NLiblet.WeakReference`1.Target" /> instance is alive.
            </summary>
      <value>
        <c>true</c> if this <see cref="P:NLiblet.WeakReference`1.Target" /> instance is alive; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="M:NLiblet.WeakReference`1.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <requires inheritedFrom="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" inheritedFromTypeName="ISerializable">info != null</requires>
    </member>
    <member name="M:NLiblet.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <requires exception="T:System.ArgumentNullException"> info != null </requires>
      <exception cref="T:System.ArgumentNullException"> info == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.GeneratedCodeHelper.CastArrayItem``1(System.Object[],System.Int32)">
      <requires exception="T:System.ArgumentNullException"> array != null </requires>
      <exception cref="T:System.ArgumentNullException"> array == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; array.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= array.Length </exception>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.System#Collections#Generic#ICollection{TItem}#Add(`1)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.System#Collections#Generic#ICollection{TItem}#Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyKeyedCollection`2.DelegatedKeyedCollection.#ctor(System.Func{`1,`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
      <requires> keyExtracter != null </requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">array.Rank == 1</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">index &lt;= array.Length + this.Count</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.System#Collections#Generic#ICollection{T}#Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlySet`1.System#Collections#ICollection#SyncRoot">
      <getter>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection">Contract.Result&lt;object&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlySet`1.System#Collections#ICollection#get_SyncRoot">
      <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection">Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.System#Collections#Generic#ICollection{T}#Add(`0)">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">array.Rank == 1</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">index &lt;= array.Length + this.Count</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.System#Collections#Generic#ICollection{T}#Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyNonListCollection`1.System#Collections#ICollection#SyncRoot">
      <getter>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection">Contract.Result&lt;object&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyNonListCollection`1.System#Collections#ICollection#get_SyncRoot">
      <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection">Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#get_Values">
      <ensures inheritedFrom="M:System.Collections.IDictionary.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#get_Values">
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
      <getter>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection">Contract.Result&lt;object&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Item(System.Object)">
      <getter>
        <requires inheritedFrom="M:System.Collections.IDictionary.get_Item(System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.IDictionary.set_Item(System.Object,System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
      </setter>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.NonGenericDictionaryEnumerator.Current">
      <getter>
        <ensures inheritedFrom="M:System.Collections.IEnumerator.get_Current" inheritedFromTypeName="IEnumerator">Contract.Result&lt;object&gt;() == this.Model[this.CurrentIndex]</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.NonGenericDictionaryEnumerator.MoveNext">
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.Model == Contract.OldValue(this.Model)</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &lt; this.Model.Length</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerator.MoveNext" inheritedFromTypeName="IEnumerator">this.CurrentIndex == Contract.OldValue(this.CurrentIndex) + 1</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Keys">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Values">
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TValue&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection">arrayIndex + this.Count  &lt;= array.Length</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#set_Item(System.Object,System.Object)">
      <requires inheritedFrom="M:System.Collections.IDictionary.set_Item(System.Object,System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#get_Keys">
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&lt;TKey&gt;&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Values">
      <getter>
        <ensures inheritedFrom="M:System.Collections.IDictionary.get_Values" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Clear">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection">this.Count == 0</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection">this.Count &gt;= Contract.OldValue(this.Count)</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#get_Keys">
      <ensures inheritedFrom="M:System.Collections.IDictionary.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">array != null</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">array.Rank == 1</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection">index &lt;= array.Length + this.Count</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
      <requires inheritedFrom="M:System.Collections.IDictionary.Remove(System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
      <requires inheritedFrom="M:System.Collections.IDictionary.Add(System.Object,System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
      <requires inheritedFrom="M:System.Collections.IDictionary.Contains(System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
    </member>
    <member name="P:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Keys">
      <getter>
        <ensures inheritedFrom="M:System.Collections.IDictionary.get_Keys" inheritedFromTypeName="IDictionary">Contract.Result&lt;ICollection&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IDictionary.GetEnumerator" inheritedFromTypeName="IDictionary">Contract.Result&lt;IDictionaryEnumerator&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#get_Item(System.Object)">
      <requires inheritedFrom="M:System.Collections.IDictionary.get_Item(System.Object)" inheritedFromTypeName="IDictionary">key != null</requires>
    </member>
    <member name="M:NLiblet.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#get_SyncRoot">
      <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection">Contract.Result&lt;object&gt;() != null</ensures>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.ForwardOnlyEnumerableStream.Position">
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Position" inheritedFromTypeName="Stream">Contract.Result&lt;Int64&gt;() &gt;= 0</ensures>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.IO.Stream.set_Position(System.Int64)" inheritedFromTypeName="Stream">value &gt;= 0</requires>
      </setter>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.ForwardOnlyEnumerableStream.SetLength(System.Int64)">
      <requires inheritedFrom="M:System.IO.Stream.SetLength(System.Int64)" inheritedFromTypeName="Stream">value &gt;= 0</requires>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.ForwardOnlyEnumerableStream.ReadByte">
      <ensures inheritedFrom="M:System.IO.Stream.ReadByte" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &gt;= -1</ensures>
    </member>
    <member name="P:NLiblet.IO.EnumerableStream.ForwardOnlyEnumerableStream.Length">
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Length" inheritedFromTypeName="Stream">Contract.Result&lt;long&gt;() &gt;= 0</ensures>
      </getter>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.ForwardOnlyEnumerableStream.Read(System.Byte[],System.Int32,System.Int32)">
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream"> count &lt;= (buffer.Length - offset)</requires>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">Contract.Result&lt;int&gt;() &lt;= count</ensures>
    </member>
    <member name="M:NLiblet.IO.EnumerableStream.ForwardOnlyEnumerableStream.Write(System.Byte[],System.Int32,System.Int32)">
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream">count &lt;= (buffer.Length - offset)</requires>
    </member>
    <member name="M:NLiblet.Text.Formatters.FormattingContext.#ctor(NLiblet.Text.Formatters.CommonCustomFormatter,System.String,System.Text.StringBuilder)">
      <requires> formatter != null </requires>
    </member>
    <member name="M:NLiblet.Text.Formatters.FormattingContext.ToString">
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.Text.DefaultCharEscapingFilter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Char,System.Char,System.Char,System.Char,System.Collections.Generic.Dictionary{System.Char,System.Char},System.Collections.Generic.Dictionary{System.Char,System.Char})">
      <requires exception="T:System.ArgumentNullException"> escapingSeqences != null </requires>
      <exception cref="T:System.ArgumentNullException"> escapingSeqences == null </exception>
      <requires exception="T:System.ArgumentNullException"> lineBreakEscapingSequences != null </requires>
      <exception cref="T:System.ArgumentNullException"> lineBreakEscapingSequences == null </exception>
    </member>
  </members>
</doc>