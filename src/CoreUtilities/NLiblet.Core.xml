<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NLiblet.CoreUtilities</name>
  </assembly>
  <members>
    <member name="T:NLiblet.Text.UnicodeUtility">
      <summary>
            	Defines utility methods related to unicode charactors handling.
            </summary>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetUnicodeBlockName(System.Int32)">
      <summary>
            	Get unicode block name of specified UTF-32 code point.
            </summary>
      <param name="codePoint">UTF-32 code point.</param>
      <returns>Unicode block name.</returns>
      <remarks>
        <para>
            You can use unicode block name in <see cref="T:System.Text.RegularExpressions.Regex" /> class.
          </para>
        <para>
            Unicode block name is defined in Unicode Standard. You can find all block name at http://www.unicode.org/Public/UNIDATA/UnicodeData.txt.
          </para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10FFFF </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10FFFF </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Char)">
      <summary>
            	Determine that whether specified charactor is printable.
            </summary>
      <param name="value">Char to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="value" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Char,System.Char)">
      <summary>
            	Determine that whether specified surrogate pair is printable.
            </summary>
      <param name="highSurrogate">High surrogate char.</param>
      <param name="lowSurrogate">Low surrogate char.</param>
      <returns>
        <c>true</c> if the codepoint represented by specified surrogate pair is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xd800 &lt;= highSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xd800 &gt; highSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> highSurrogate &lt;= 0xdbff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> highSurrogate &gt; 0xdbff </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xdc00 &lt;= lowSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xdc00 &gt; lowSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> lowSurrogate &lt;= 0xdfff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> lowSurrogate &gt; 0xdfff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.String,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.String" /> is printable.
            </summary>
      <param name="value">
        <see cref="T:System.String" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Text.StringBuilder,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.Text.StringBuilder" /> is printable.
            </summary>
      <param name="value">
        <see cref="T:System.Text.StringBuilder" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Collections.Generic.IList{System.Char},System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified charactor collection is printable.
            </summary>
      <param name="chars">
        <see cref="T:System.Collections.Generic.IList`1" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="chars" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> chars != null </requires>
      <exception cref="T:System.ArgumentNullException"> chars == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; chars.Count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= chars.Count </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.IsPrintable(System.Int32)">
      <summary>
            	Determine that whether specified UTF-32 code point is printable.
            </summary>
      <param name="codePoint">UTF-32 code point to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="codePoint" /> is printable; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>false</c> to charactors which is always non-printable.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item><item>White space</item></list>
            Note that any modifiers and private used charactors are considered printable.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors are also considered NON-printable.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10ffff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10ffff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Char)">
      <summary>
            	Determine that whether specified charactor should be escaped.
            </summary>
      <param name="value">Char to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="value" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Char,System.Char)">
      <summary>
            	Determine that whether specified surrogate pair should be escaped.
            </summary>
      <param name="highSurrogate">High surrogate char.</param>
      <param name="lowSurrogate">Low surrogate char.</param>
      <returns>
        <c>true</c> if the codepoint represented by specified surrogate pair should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xd800 &lt;= highSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xd800 &gt; highSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> highSurrogate &lt;= 0xdbff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> highSurrogate &gt; 0xdbff </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0xdc00 &lt;= lowSurrogate </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0xdc00 &gt; lowSurrogate </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> lowSurrogate &lt;= 0xdfff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> lowSurrogate &gt; 0xdfff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.String,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.String" /> should be escaped.
            </summary>
      <param name="value">
        <see cref="T:System.String" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Text.StringBuilder,System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified <see cref="T:System.Text.StringBuilder" /> should be escaped.
            </summary>
      <param name="value">
        <see cref="T:System.Text.StringBuilder" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="value" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> value != null </requires>
      <exception cref="T:System.ArgumentNullException"> value == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; value.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= value.Length </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Collections.Generic.IList{System.Char},System.Int32)">
      <summary>
            	Determine that whether the codepoint at the index in specified charactor collection should be escaped.
            </summary>
      <param name="chars">
        <see cref="T:System.Collections.Generic.IList`1" /> holds target charactor.</param>
      <param name="index">Index of determining charactor. You can specify the position of high surrogate char for surrogate pair.</param>
      <returns>
        <c>true</c> if charactor at <paramref name="index" /> in <paramref name="chars" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentNullException"> chars != null </requires>
      <exception cref="T:System.ArgumentNullException"> chars == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= index </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; index </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> index &lt; chars.Count </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> index &gt;= chars.Count </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.ShouldEscape(System.Int32)">
      <summary>
            	Determine that whether specified UTF-32 code point should be escaped.
            </summary>
      <param name="codePoint">UTF-32 code point to be determined.</param>
      <returns>
        <c>true</c> if <paramref name="codePoint" /> should be escaped; otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            This method returns <c>true</c> to charactors which should be escaped in trace/logging message.
            Such charactors include:
            <list type="bullet"><item>
                Control charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.Control" />(Cc).
              </item><item>
                Orphan surrogate char. Its category is <see cref="F:System.Globalization.UnicodeCategory.Surrogate" />(Cs).
              </item><item>
                Unassigned charactor. Its category is <see cref="F:System.Globalization.UnicodeCategory.OtherNotAssigned" />(On).
              </item></list>
            Note that any modifiers and private used charactors should not be escaped.
          </para>
        <note>
            Line feed, page feed, cariage return, and horizontal/vertical tab charactors should also be escaped.
          </note>
        <para>
            This method does not take into account presentation related issues.
            There serveral factors to prevent to 'print' charactor(s) in your display surface or external media including:
            <list type="bullet"><item>
                Required fonts are not installed.
                For example, 'Lucida Console' does not have any glyphs for Japanese charactors.
              </item><item>
                The program cannot have capability to change their fonts appropriately.
                For example, customized text control in some tools cannot display Japanese text due to lack of the capability.
              </item><item>
                White space. Note that there are several white space charactors other than ASCII white space (U+0020) like
                full-width white space (U+3000).
              </item></list></para>
      </remarks>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= codePoint </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; codePoint </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> codePoint &lt;= 0x10ffff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> codePoint &gt; 0x10ffff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetUnicodeCategory(System.Int32)">
      <summary>
            	Get <see cref="T:System.Globalization.UnicodeCategory" /> for specified UTF-32 code point.
            </summary>
      <param name="utf32">UTF-32 code point.</param>
      <returns>
        <see cref="T:System.Globalization.UnicodeCategory" />.</returns>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= utf32 &amp;&amp; utf32 &lt;= 0x10ffff </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; utf32 || utf32 &gt; 0x10ffff </exception>
    </member>
    <member name="M:NLiblet.Text.UnicodeUtility.GetUnicodeBlockName(System.Char)">
      <summary>
            	Get unicode block name of specified UTF-16 charctor.
            </summary>
      <param name="utf16">Charactor.</param>
      <returns>Unicode block name.</returns>
      <remarks>
        <para>
            You can use unicode block name in <see cref="T:System.Text.RegularExpressions.Regex" /> class.
          </para>
        <para>
            Unicode block name is defined in Unicode Standard. You can find all block name at http://www.unicode.org/Public/UNIDATA/UnicodeData.txt.
          </para>
      </remarks>
    </member>
    <member name="T:NLiblet.Reflection.GenericTypeExtensions">
      <summary>
            	Define utility extension method for generic type.
            </summary>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.Inherits(System.Type,System.Type)">
      <summary>
            	Determine whether source type inherits directly or indirectly from specified generic type or its built type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericTypeDefinition">Generic type definition.</param>
      <returns>
        <c>true</c> if <paramref name="source" />, directly or indirectly, inherits from <paramref name="genericTypeDefinition" />,
            	or built closed generic type;
            	otherwise <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentNullException"> genericTypeDefinition != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericTypeDefinition == null </exception>
      <requires exception="T:System.ArgumentException"> genericTypeDefinition.IsGenericTypeDefinition </requires>
      <exception cref="T:System.ArgumentException">!( genericTypeDefinition.IsGenericTypeDefinition )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.Implements(System.Type,System.Type)">
      <summary>
            	Determine whether source type implements specified generic type or its built type.
            </summary>
      <param name="source">Target type.</param>
      <param name="genericTypeDefinition">Generic interface type definition.</param>
      <returns>
        <c>true</c> if <paramref name="source" /> implements <paramref name="genericTypeDefinition" />,
            	or built closed generic interface type;
            	otherwise <c>false</c>.
            </returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentNullException"> genericTypeDefinition != null </requires>
      <exception cref="T:System.ArgumentNullException"> genericTypeDefinition == null </exception>
      <requires exception="T:System.ArgumentException"> genericTypeDefinition.IsInterface </requires>
      <exception cref="T:System.ArgumentException">!( genericTypeDefinition.IsInterface )</exception>
      <requires exception="T:System.ArgumentException"> genericTypeDefinition.IsGenericTypeDefinition </requires>
      <exception cref="T:System.ArgumentException">!( genericTypeDefinition.IsGenericTypeDefinition )</exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.GetName(System.Type)">
      <summary>
            	Get name of type without namespace and assembly name of itself and its generic arguments.
            </summary>
      <param name="source">Target type.</param>
      <returns>Simple name of type.</returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.GetFullName(System.Type)">
      <summary>
            	Get full name of type including namespace and excluding assembly name of itself and its generic arguments.
            </summary>
      <param name="source">Target type.</param>
      <returns>Full name of type.</returns>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="M:NLiblet.Reflection.GenericTypeExtensions.Equals(System.Type,System.Type)">
      <summary>
            	Determines whether the specified same type other <see cref="T:System.Type" /> is equal to the instance.
            </summary>
      <param name="source">The <see cref="T:System.Type" /> to compare with <paramref name="other" /> instance.</param>
      <param name="other">The <see cref="T:System.Type" /> to compare with <paramref name="source" /> instance.</param>
      <returns>
        <c>true</c> if <paramref name="other" /> is equal to <paramref name="source" /> instance; otherwise, <c>false</c>.
            </returns>
      <remarks>
            	This method compares <see cref="P:System.Type.TypeHandle" /> property.
            </remarks>
      <pure />
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
    </member>
    <member name="T:NLiblet.Text.FormatProviders">
      <summary>
            	Defines NLiblet <see cref="T:System.IFormatProvider" />.
            </summary>
      <remarks>
        <list type="table">
          <listheader>
            <term>Format indicator</term>
            <description>Behavior</description>
          </listheader>
          <item>
            <term>a, A</term>
            <description>
              <strong>A</strong>SCII; all non-ascii charcters will be escaped with \uxxxx syntax.
              Note that alphabet characeters in hexadecimal is always uppercase.
            </description>
          </item>
          <item>
            <term>b, B</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Unicode <strong>b</strong>lock name.
              <note>
                Currently not supported.
              </note></description>
          </item>
          <item>
            <term>c, C</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Unicode <strong>c</strong>ategory
            </description>
          </item>
          <item>
            <term>d, D</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              <strong>D</strong>ecimal representation of unicode codepoint.
            </description>
          </item>
          <item>
            <term>e, E</term>
            <description>
              <strong>E</strong>scaping non printable chars with U+FFFD.
            </description>
          </item>
          <item>
            <term>g, G</term>
            <description>
              <strong>G</strong>eneral; same as 'm'.
            </description>
          </item>
          <item>
            <term>l, L</term>
            <description>
              <strong>L</strong>iteral style.
              It is similar to 's' style, but additionaly escape '"' to '\"'.
              <note>
                String entity in collections will be always escaped using this style.
              </note></description>
          </item>
          <item>
            <term>m, M</term>
            <description>
              <strong>M</strong>ulti line escaped char with \uxxxx notation.
              All control chars without line breaks, orphen surrogate, non-assinged code points will be escaped.
            </description>
          </item>
          <item>
            <term>r, R</term>
            <description>
              Raw-char without any escaping. It means that no escaping will not be performed.
            </description>
          </item>
          <item>
            <term>s, S</term>
            <description>
              <strong>S</strong>ulti line escaped char with \uxxxx notation.
              All control chars with line breaks, orphen surrogate, non-assinged code points will be escaped.
            </description>
          </item>
          <item>
            <term>u, U</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Int32" />.
              </em>
              Consider specified <see cref="T:System.Int32" /> value as <strong>U</strong>tf-32.
              You can specify additional format sepcifier following this like 'l', 'm', 's', 'x', etc. in this table to control format of UTF-32 value.
              Note that you cannot specify additional 'u' specifier since it is nonsense.
              For example, value '1' with format "uc" will be "Control", '0x61' with format "ub" will be "BasicLatin", and '0x1F0A1' with format "ur" will be spade ace mark.
            </description>
          </item>
          <item>
            <term>x</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Utf-16 he<strong>x</strong>, with alphabets in hex representation will be uppercase.
            </description>
          </item>
          <item>
            <term>X</term>
            <description>
              <em>
                This indicator is only valid to <see cref="T:System.Char" />, <see cref="T:System.Globalization.StringInfo" />, <see cref="T:System.Int32" />(considered as UTF-32).
              </em>
              Utf-16 he<strong>x</strong>, with alphabets in hex representation will be uppercase.
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:NLiblet.Text.FormatProviders.CurrentCulture">
      <summary>
            	Get <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Threading.Thread.CurrentCulture" />.
            </summary>
      <value>
        <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Threading.Thread.CurrentCulture" />.</value>
      <getter>
        <ensures> Contract.Result&lt;IFormatProvider&gt;() != null </ensures>
      </getter>
    </member>
    <member name="P:NLiblet.Text.FormatProviders.InvariantCulture">
      <summary>
            	Get <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
      <value>
        <see cref="T:System.IFormatProvider" /> bounds to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.</value>
      <getter>
        <ensures> Contract.Result&lt;IFormatProvider&gt;() != null </ensures>
      </getter>
    </member>
    <member name="T:NLiblet.HashCodeBuilder">
      <summary>
            	Provide hash code building feature.
            </summary>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.Append``1(``0)">
      <summary>
            	Append hash code for specified value and returns new <see cref="T:NLiblet.HashCodeBuilder" /> to chain.
            </summary>
      <typeparam name="T">Type of value.</typeparam>
      <param name="value">Value to append its hash code. This value can be <c>null</c>.</param>
      <returns>New <see cref="T:NLiblet.HashCodeBuilder" /> to chain.</returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.BuildHashCode">
      <summary>
            	Get hash code built.
            </summary>
      <returns>Hash code built.</returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.GetHashCode">
      <summary>
            	Get hash code built.
            </summary>
      <returns>Hash code built.</returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.Equals(System.Object)">
      <summary>
            	Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.Equals(NLiblet.HashCodeBuilder)">
      <summary>
            	Determines whether the specified same type other <see cref="T:NLiblet.HashCodeBuilder" /> is equal to this instance.
            </summary>
      <param name="other">The <see cref="T:NLiblet.HashCodeBuilder" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if <paramref name="other" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.op_Equality(NLiblet.HashCodeBuilder,NLiblet.HashCodeBuilder)">
      <summary>
            	Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>
            	The result of the operator.
            </returns>
    </member>
    <member name="M:NLiblet.HashCodeBuilder.op_Inequality(NLiblet.HashCodeBuilder,NLiblet.HashCodeBuilder)">
      <summary>
            	Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>
            	The result of the operator.
            </returns>
    </member>
    <member name="T:NLiblet.Empty">
      <summary>
            	Utlities for empty collections.
            </summary>
    </member>
    <member name="M:NLiblet.Empty.Array``1">
      <summary>
            	Get singleton empty array for specified type.
            </summary>
      <typeparam name="T">Type of array.</typeparam>
      <returns>Singleton instance of empty array.</returns>
      <remarks>
            	Empty array is immutable.
            </remarks>
      <ensures> Contract.Result&lt;T[]&gt;() != null </ensures>
      <ensures> Contract.Result&lt;T[]&gt;().Length == 0 </ensures>
    </member>
    <member name="M:NLiblet.Empty.ReadOnlyCollection``1">
      <summary>
            	Get singleton empty <see cref="M:NLiblet.Empty.ReadOnlyCollection``1" /> for specified type.
            </summary>
      <typeparam name="T">Item type of <see cref="M:NLiblet.Empty.ReadOnlyCollection``1" />.</typeparam>
      <returns>Singleton instance of empty <see cref="M:NLiblet.Empty.ReadOnlyCollection``1" />.</returns>
      <ensures> Contract.Result&lt;ReadOnlyCollection&lt;T&gt;&gt;() != null </ensures>
      <ensures> Contract.Result&lt;ReadOnlyCollection&lt;T&gt;&gt;().Count == 0 </ensures>
    </member>
    <member name="T:NLiblet.Arrays">
      <summary>
            	Utilities for array.
            </summary>
    </member>
    <member name="M:NLiblet.Arrays.Empty``1">
      <summary>
            	Get singleton empty array for specified type.
            </summary>
      <typeparam name="T">Type of array.</typeparam>
      <returns>Singleton instance of empty array.</returns>
      <remarks>
            	Empty array is immutable.
            </remarks>
      <ensures> Contract.Result&lt;T[]&gt;() != null </ensures>
    </member>
    <member name="T:NLiblet.Text.StringBuilderExtensions">
      <summary>
            	Extends <see cref="T:System.Text.StringBuilder" /> with extension methods.
            </summary>
    </member>
    <member name="M:NLiblet.Text.StringBuilderExtensions.AsEnumerable(System.Text.StringBuilder)">
      <summary>
            	Get <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerate characters of this <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="source">
        <see cref="T:System.Text.StringBuilder" />.</param>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> to enumerate characters of <paramref name="source" />.</returns>
    </member>
    <member name="M:NLiblet.Text.StringBuilderExtensions.AppendHex(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            	Append bytes as hexdecimal representation to this <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="source">
        <see cref="T:System.Text.StringBuilder" />.</param>
      <param name="bytes">Bytes. This value can be null.</param>
      <returns>
        <paramref name="source" /> to be used for chaining.</returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <ensures> Contract.Result&lt;StringBuilder&gt;() != null </ensures>
      <ensures> Object.ReferenceEquals( Contract.Result&lt;StringBuilder&gt;(), source ) </ensures>
    </member>
    <member name="M:NLiblet.Text.StringBuilderExtensions.AppendChars(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            	Append characters to this <see cref="T:System.Text.StringBuilder" />.
            </summary>
      <param name="source">
        <see cref="T:System.Text.StringBuilder" />.</param>
      <param name="chars">Characters. This value can be null.</param>
      <returns>
        <paramref name="source" /> to be used for chaining.</returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <ensures> Contract.Result&lt;StringBuilder&gt;() != null </ensures>
      <ensures> Object.ReferenceEquals( Contract.Result&lt;StringBuilder&gt;(), source ) </ensures>
    </member>
    <member name="T:NLiblet.StringExtensions">
      <summary>
            	Extends <see cref="T:System.String" /> with extension methods.
            </summary>
    </member>
    <member name="M:NLiblet.StringExtensions.Slice(System.String,System.Int32,System.Int32)">
      <summary>
            	Get slice of string.
            </summary>
      <param name="source">
        <see cref="T:System.String" />.</param>
      <param name="start">Start index, inclusive.</param>
      <param name="end">End index, inclusive.</param>
      <returns>Slice of <paramref name="source" />.</returns>
      <requires exception="T:System.ArgumentNullException"> source != null </requires>
      <exception cref="T:System.ArgumentNullException"> source == null </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= start </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; start </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> start &lt; source.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> start &gt;= source.Length </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> 0 &lt;= end </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> 0 &gt; end </exception>
      <requires exception="T:System.ArgumentOutOfRangeException"> end &lt; source.Length </requires>
      <exception cref="T:System.ArgumentOutOfRangeException"> end &gt;= source.Length </exception>
      <requires exception="T:System.InvalidOperationException"> start &lt;= end </requires>
      <exception cref="T:System.InvalidOperationException"> start &gt; end </exception>
    </member>
    <member name="T:NLiblet.WeakReference`1">
      <summary>
            Represents typed 'weak' reference.
            </summary>
      <typeparam name="T">Type of reference type to be wrapped.</typeparam>
    </member>
    <member name="M:NLiblet.WeakReference`1.#ctor(`0)">
      <summary>
            	Initializes a new instance without resurrection tracking.
            </summary>
      <param name="target">The target. This value is non-<c>null</c> reference type object.</param>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.WeakReference`1.#ctor(`0,System.Boolean)">
      <summary>
            	Initializes a new instance with specified resurrection tracking.
            </summary>
      <param name="target">The target. This value is non-<c>null</c> reference type object.</param>
      <param name="trackResurrection">If tracking resurrection then <c>true</c>; otherwise <c>false</c>.</param>
      <requires exception="T:System.ArgumentNullException"> target != null </requires>
      <exception cref="T:System.ArgumentNullException"> target == null </exception>
    </member>
    <member name="M:NLiblet.WeakReference`1.Finalize">
      <summary>
            	Releases unmanaged resources and performs other cleanup operations before the
            	<see cref="T:NLiblet.WeakReference`1" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:NLiblet.WeakReference`1.Dispose">
      <summary>
            	Releases unmanaged resources and performs other cleanup operations before the
            	<see cref="T:NLiblet.WeakReference`1" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="P:NLiblet.WeakReference`1.TrackResurrection">
      <summary>
            	Gets a value indicating whether this reference tracking resurrection.
            </summary>
      <value>
        <c>true</c> if this reference tracking resurrection; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NLiblet.WeakReference`1.Target">
      <summary>
            	Gets the target object as strong reference.
            </summary>
      <value>
            	Wrapped target value. This value may not be <c>null</c>.
            </value>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="P:NLiblet.WeakReference`1.IsAlive" /> is <c>false</c>, thus target object has been already reclaimed by GC.
            </exception>
      <remarks>
            	It is possible target object has been reclaimed since most recent <see cref="P:NLiblet.WeakReference`1.IsAlive" /> call
            	because of the nature of multi-threaded environment.
            </remarks>
    </member>
    <member name="P:NLiblet.WeakReference`1.IsAlive">
      <summary>
            	Gets a value indicating whether <see cref="P:NLiblet.WeakReference`1.Target" /> instance is alive.
            </summary>
      <value>
        <c>true</c> if this <see cref="P:NLiblet.WeakReference`1.Target" /> instance is alive; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter">
      <summary>
            	Implementing <see cref="T:System.ICustomFormatter" /> and <see cref="T:System.IFormatProvider" />.
            </summary>
    </member>
    <member name="M:NLiblet.Text.CommonCustomFormatter.#ctor(System.IFormatProvider)">
      <summary>
            	Initializes a new instance of the <see cref="T:NLiblet.Text.CommonCustomFormatter" /> class.
            </summary>
      <param name="defaultFormatProvider">Format provider to format <see cref="T:System.IFormattable" /> items.</param>
      <requires exception="T:System.ArgumentNullException"> defaultFormatProvider != null </requires>
      <exception cref="T:System.ArgumentNullException"> defaultFormatProvider == null </exception>
    </member>
    <member name="M:NLiblet.Text.CommonCustomFormatter.IsNumerics(System.RuntimeTypeHandle,System.Boolean@)">
      <summary>
            	Determine whether specified type is numeric.
            </summary>
      <param name="typeHandle">Type handle.</param>
      <param name="isFormattable">Set true if <paramref name="typeHandle" /> is formattable.</param>
      <returns>
        <c>true</c> if sepcified type is numerics.</returns>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.FormattingContext">
      <summary>
            	Consolidates context information.
            </summary>
    </member>
    <member name="P:NLiblet.Text.CommonCustomFormatter.FormattingContext.Format">
      <summary>
            	Get format string specified to Format().
            </summary>
    </member>
    <member name="P:NLiblet.Text.CommonCustomFormatter.FormattingContext.FallbackProvider">
      <summary>
            	Get fallback provider which was passed on constructor. This value may be CultureInfo.
            </summary>
    </member>
    <member name="P:NLiblet.Text.CommonCustomFormatter.FormattingContext.Buffer">
      <summary>
            	Get buffer to append formatting result.
            </summary>
    </member>
    <member name="P:NLiblet.Text.CommonCustomFormatter.FormattingContext.Formatter">
      <summary>
            	Get the reference to current <see cref="T:NLiblet.Text.CommonCustomFormatter" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.ItemFormatter">
      <summary>
            	Define non-geneneric entry points for item formatting.
            </summary>
    </member>
    <member name="M:NLiblet.Text.CommonCustomFormatter.ItemFormatter.Get(System.Type)">
      <summary>
            	Get appropriate formatter.
            </summary>
      <param name="itemType">Type of item.</param>
      <returns>Appropriate formatter.</returns>
      <requires> itemType != null </requires>
      <ensures> Contract.Result&lt;ItemFormatter&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Text.CommonCustomFormatter.ItemFormatter.FormatTo(System.Object,NLiblet.Text.CommonCustomFormatter.FormattingContext)">
      <summary>
            	Format specified item using context.
            </summary>
      <param name="item">Item to be formatted.</param>
      <param name="context">Context information.</param>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.ObjectFormatter">
      <summary>
        <see cref="T:NLiblet.Text.CommonCustomFormatter.ItemFormatter" /> specialized for <see cref="T:System.Object" />.
            </summary>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.ItemFormatter`1">
      <summary>
            	Type specific <see cref="T:NLiblet.Text.CommonCustomFormatter.ItemFormatter" /> implementation.
            </summary>
      <typeparam name="T">Type of item.</typeparam>
    </member>
    <member name="M:NLiblet.Text.CommonCustomFormatter.ItemFormatter`1.#cctor">
      <summary>
            	Initialize closed type specialized for <typeparamref name="T" /> type.
            </summary>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.SequenceFormatter">
      <summary>
            	Non-generic entrypoint for sequence formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.SequenceFormatter`1">
      <summary>
            	Formatter for generic sequence.
            </summary>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.DictionaryFormatter">
      <summary>
            	Non-generic entrypoint for dictionary formatter.
            </summary>
    </member>
    <member name="T:NLiblet.Text.CommonCustomFormatter.DictionaryFormatter`2">
      <summary>
            	Generic formatter for dictionary/map.
            </summary>
    </member>
    <member name="T:NLiblet.Text.HexFormat">
      <summary>
            	Text format utilities for hexadecimal binary text representation.
            </summary>
    </member>
    <member name="M:NLiblet.Text.HexFormat.ToHexString(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            	Returns hexadecimal text representation of specified bytes.
            </summary>
      <param name="bytes">Bytes to be string. This value can be null.</param>
      <returns>
            	Hexadecimal text representation of specified <paramref name="bytes" />;
            	or empty string when <paramref name="bytes" /> is null or empty.
            </returns>
      <pure />
      <ensures> Contract.Result&lt;string&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.Text.HexFormat.ToHex(System.Collections.Generic.IEnumerable{System.Byte})">
      <summary>
            	Returns hexadecimal text representation of specified bytes.
            </summary>
      <param name="bytes">Bytes to be string. This value can be null.</param>
      <returns>
            	Charactor sequence of hexadecimal text representation of specified <paramref name="bytes" />;
            	or empty sequence when <paramref name="bytes" /> is null or empty.
            </returns>
      <pure />
    </member>
    <member name="M:NLiblet.Text.HexFormat.GetBytesFromHex(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            	Returns binary representation of specified hexadicimal format text.
            </summary>
      <param name="hexChars">Chars to be binary. This value can be null.</param>
      <returns>
            	Byte sequence of binary representation of specified <paramref name="hexChars" />;
            	or empty sequence when <paramref name="hexChars" /> is null or empty.
            </returns>
      <exception cref="T:System.FormatException">
        <paramref name="hexChars" /> contains invalid charactor. Valid charactor is ASCII numbers or ACSII 'a', 'b', 'c', 'd', 'e', or 'f' (cases are insensitive).
            </exception>
      <pure />
    </member>
    <member name="M:NLiblet.Text.HexFormat.GetByteArrayFromHex(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            	Returns byte array for specified hexadicimal format text.
            </summary>
      <param name="hexChars">Chars to be binary. This value can be null.</param>
      <returns>
            	Byte array of binary representation of specified <paramref name="hexChars" />;
            	or empty sequence when <paramref name="hexChars" /> is null or empty.
            </returns>
      <exception cref="T:System.FormatException">
        <paramref name="hexChars" /> contains invalid charactor. Valid charactor is ASCII numbers or ACSII 'a', 'b', 'c', 'd', 'e', or 'f' (cases are insensitive).
            </exception>
      <pure />
      <ensures> Contract.Result&lt;byte[]&gt;() != null </ensures>
    </member>
    <member name="M:NLiblet.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <requires exception="T:System.ArgumentNullException"> info != null </requires>
      <exception cref="T:System.ArgumentNullException"> info == null </exception>
    </member>
    <member name="M:NLiblet.WeakReference`1.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <requires inheritedFrom="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" inheritedFromTypeName="ISerializable">info != null</requires>
    </member>
    <member name="M:NLiblet.Text.CommonCustomFormatter.FormattingContext.#ctor(NLiblet.Text.CommonCustomFormatter,System.String,System.Text.StringBuilder)">
      <requires> formatter != null </requires>
    </member>
    <member name="M:NLiblet.Text.DefaultCharEscapingFilter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Char,System.Char,System.Char,System.Char,System.Collections.Generic.Dictionary{System.Char,System.Char},System.Collections.Generic.Dictionary{System.Char,System.Char})">
      <requires exception="T:System.ArgumentNullException"> escapingSeqences != null </requires>
      <exception cref="T:System.ArgumentNullException"> escapingSeqences == null </exception>
      <requires exception="T:System.ArgumentNullException"> lineBreakEscapingSequences != null </requires>
      <exception cref="T:System.ArgumentNullException"> lineBreakEscapingSequences == null </exception>
    </member>
  </members>
</doc>